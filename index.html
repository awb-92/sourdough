<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Sourdough">
    <title>Sourdough Timer</title>
    
    <!-- iOS Icons -->
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'><rect width='180' height='180' fill='%23667eea'/><text x='50%' y='50%' text-anchor='middle' dy='.35em' font-size='100' fill='white'>üçû</text></svg>">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='75' font-size='75'>üçû</text></svg>">
    
    <!-- Theme Color -->
    <meta name="theme-color" content="#0f0f0f">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Proxima Nova', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0f0f0f;
            color: #e0e0e0;
            padding: 16px;
            padding-bottom: 80px; /* Extra space for mobile scrolling */
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            color: #ffffff;
            margin-bottom: 24px;
            font-size: 1.75em;
        }

        @media (min-width: 768px) {
            body {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
                margin-bottom: 30px;
            }
        }

        /* Active Timer Banner */
        .timer-banner {
            position: sticky;
            top: -16px; /* Offset for body padding */
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 16px;
            border-radius: 12px;
            margin: -16px -16px 16px -16px; /* Extend to edges on mobile */
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            z-index: 100;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .timer-banner:active {
            transform: scale(0.98);
        }

        .timer-banner .banner-content {
            pointer-events: none;
        }

        @media (min-width: 768px) {
            .timer-banner {
                top: 0;
                margin: 0 0 20px 0;
                padding: 20px;
            }
        }

        .timer-banner.per-bake {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        .timer-banner h2 {
            font-size: 1em;
            margin-bottom: 8px;
            opacity: 0.9;
        }

        .timer-banner .current-step {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .timer-banner .time-remaining {
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 8px;
        }

        @media (min-width: 768px) {
            .timer-banner h2 {
                font-size: 1.2em;
                margin-bottom: 10px;
            }

            .timer-banner .current-step {
                font-size: 1.5em;
                margin-bottom: 10px;
            }

            .timer-banner .time-remaining {
                font-size: 2em;
                margin-bottom: 10px;
            }
        }

        .timer-banner .next-step {
            opacity: 0.8;
            font-size: 0.85em;
        }

        .timer-progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            margin: 10px 0;
            overflow: hidden;
        }

        .timer-progress-fill {
            height: 100%;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 3px;
            transition: width 1s linear;
            width: 100%;
        }

        .timer-progress-fill.done {
            background: #ffd700;
            width: 0%;
        }

        /* Buttons */
        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 14px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            transition: all 0.3s;
            min-height: 48px; /* Touch-friendly */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
        }

        @media (hover: hover) {
            .btn:hover {
                background: #5568d3;
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
            }
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: #2a2a2a;
        }

        @media (hover: hover) {
            .btn-secondary:hover {
                background: #3a3a3a;
            }
        }

        .btn-danger {
            background: #dc3545;
        }

        @media (hover: hover) {
            .btn-danger:hover {
                background: #c82333;
            }
        }

        .btn-success {
            background: #28a745;
        }

        @media (hover: hover) {
            .btn-success:hover {
                background: #218838;
            }
        }

        /* Active Bakes Section */
        .active-bakes {
            margin-bottom: 24px;
        }

        .bake-card {
            background: #1a1a1a;
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            border: 1px solid #2a2a2a;
        }

        @media (min-width: 768px) {
            .active-bakes {
                margin-bottom: 30px;
            }
            
            .bake-card {
                padding: 20px;
                margin-bottom: 15px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
        }

        .bake-card-info h3 {
            color: #ffffff;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        .bake-card-info p {
            color: #a0a0a0;
            font-size: 0.85em;
            line-height: 1.5;
        }

        .bake-card-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        @media (min-width: 768px) {
            .bake-card-actions {
                margin-top: 0;
                gap: 10px;
            }
        }

        /* Recipe Selection */
        .recipe-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            margin-top: 16px;
        }

        @media (min-width: 600px) {
            .recipe-grid {
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 20px;
                margin-top: 20px;
            }
        }

        .recipe-card {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            border: 1px solid #2a2a2a;
            min-height: 110px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        @media (hover: hover) {
            .recipe-card:hover {
                transform: translateY(-3px);
                box-shadow: 0 8px 16px rgba(0,0,0,0.4);
                border-color: #667eea;
            }
        }

        .recipe-card:active {
            transform: translateY(-1px);
        }

        .recipe-card h3 {
            color: #ffffff;
            margin-bottom: 8px;
            font-size: 1.15em;
        }

        .recipe-card p {
            color: #a0a0a0;
            font-size: 0.9em;
            line-height: 1.4;
        }

        /* Timeline Setup */
        .timeline-setup {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            border: 1px solid #2a2a2a;
        }

        @media (min-width: 768px) {
            .timeline-setup {
                padding: 30px;
            }
        }

        .mode-selector {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            margin: 16px 0;
        }

        @media (min-width: 600px) {
            .mode-selector {
                grid-template-columns: 1fr 1fr;
                gap: 15px;
                margin: 20px 0;
            }
        }

        .mode-btn {
            padding: 16px;
            border: 2px solid #2a2a2a;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            background: #0f0f0f;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .mode-btn.active {
            border-color: #667eea;
            background: #1a1a2a;
        }

        .mode-btn h3 {
            color: #ffffff;
            margin-bottom: 6px;
            font-size: 1.05em;
        }

        .mode-btn p {
            color: #a0a0a0;
            font-size: 0.85em;
        }

        .form-group {
            margin: 16px 0;
        }

        @media (min-width: 768px) {
            .form-group {
                margin: 20px 0;
            }
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #e0e0e0;
            font-weight: 500;
            font-size: 0.95em;
        }

        .form-group input[type="datetime-local"] {
            width: 100%;
            padding: 14px;
            border: 2px solid #2a2a2a;
            border-radius: 8px;
            font-size: 1em;
            background: #0f0f0f;
            color: #e0e0e0;
            min-height: 48px;
            /* Allow past dates */
        }

        .form-group input[type="datetime-local"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-group .hint {
            font-size: 0.85em;
            color: #a0a0a0;
            margin-top: 6px;
        }

        /* Options Section */
        .options-section {
            margin: 20px 0;
        }

        .options-section h3 {
            color: #ffffff;
            margin-bottom: 12px;
            font-size: 1.1em;
        }

        .option-group {
            margin: 12px 0;
            padding: 16px;
            background: #0f0f0f;
            border-radius: 8px;
            border: 1px solid #2a2a2a;
        }

        .option-group h4 {
            color: #e0e0e0;
            margin-bottom: 10px;
            font-size: 1em;
        }

        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }

        @media (min-width: 600px) {
            .radio-group {
                flex-direction: row;
                gap: 15px;
            }
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            min-height: 44px; /* Touch-friendly */
        }

        .radio-option label {
            color: #e0e0e0;
            cursor: pointer;
            font-size: 0.95em;
        }

        .radio-option input[type="radio"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #667eea;
        }

        /* Step Selector */
        .step-selector {
            margin: 20px 0;
            padding: 16px;
            background: #0f0f0f;
            border-radius: 8px;
            border: 1px solid #2a2a2a;
        }

        .step-selector h4 {
            color: #e0e0e0;
            margin-bottom: 12px;
            font-size: 1em;
        }

        .step-selector select {
            width: 100%;
            padding: 12px;
            background: #1a1a1a;
            border: 2px solid #2a2a2a;
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 1em;
            min-height: 48px;
            cursor: pointer;
        }

        .step-selector select:focus {
            outline: none;
            border-color: #667eea;
        }

        .step-selector .hint {
            font-size: 0.85em;
            color: #a0a0a0;
            margin-top: 6px;
        }

        /* Ingredients Checklist */
        .ingredients-section {
            background: #1a1a1a;
            padding: 16px;
            border-radius: 12px;
            margin: 16px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            border: 1px solid #2a2a2a;
        }

        @media (min-width: 768px) {
            .ingredients-section {
                padding: 20px;
                margin: 20px 0;
            }
        }

        .ingredients-section h3 {
            color: #ffffff;
            margin-bottom: 12px;
            font-size: 1.1em;
        }

        .ingredient-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            margin: 6px 0;
            border-radius: 6px;
            transition: background 0.2s;
            min-height: 48px; /* Touch-friendly */
        }

        @media (hover: hover) {
            .ingredient-item:hover {
                background: #2a2a2a;
            }
        }

        .ingredient-item label {
            color: #e0e0e0;
            cursor: pointer;
            flex: 1;
        }

        .ingredient-item input[type="checkbox"] {
            width: 22px;
            height: 22px;
            cursor: pointer;
            accent-color: #667eea;
            flex-shrink: 0;
        }

        .ingredient-item.checked label {
            opacity: 0.5;
            text-decoration: line-through;
        }

        /* Timeline View */
        .timeline-view {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            border: 1px solid #2a2a2a;
        }

        @media (min-width: 768px) {
            .timeline-view {
                padding: 30px;
            }
        }

        .timeline-view h2 {
            color: #ffffff;
            font-size: 1.3em;
        }

        .timeline-view > div > p {
            color: #a0a0a0;
            font-size: 0.85em;
            margin-top: 4px;
        }

        .step-card {
            background: #0f0f0f;
            padding: 16px;
            border-radius: 8px;
            margin: 12px 0;
            border-left: 4px solid #667eea;
            border: 1px solid #2a2a2a;
            border-left: 4px solid #667eea;
        }

        @media (min-width: 768px) {
            .step-card {
                padding: 20px;
                margin: 15px 0;
            }
        }

        .step-card.completed {
            opacity: 0.6;
            border-left-color: #28a745;
        }

        .step-card.active {
            background: #1a1a2a;
            border-left-color: #764ba2;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            border: 1px solid #667eea;
            border-left: 4px solid #764ba2;
        }

        .step-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
            gap: 12px;
        }

        .step-title {
            font-size: 1.1em;
            font-weight: 600;
            color: #ffffff;
            line-height: 1.3;
        }

        .step-time {
            color: #667eea;
            font-weight: 500;
            font-size: 0.9em;
            text-align: right;
            flex-shrink: 0;
        }

        .step-duration {
            color: #a0a0a0;
            font-size: 0.85em;
            margin: 5px 0;
        }

        .step-guidance {
            margin-top: 12px;
        }

        .guidance-toggle {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-size: 0.9em;
            padding: 8px 0;
            text-decoration: underline;
            min-height: 44px; /* Touch-friendly */
        }

        .guidance-content {
            margin-top: 10px;
            padding: 12px;
            background: #1a1a1a;
            border-radius: 6px;
            font-size: 0.9em;
            line-height: 1.6;
            color: #d0d0d0;
            border: 1px solid #2a2a2a;
        }

        .guidance-content strong {
            color: #ffffff;
        }

        .guidance-content ul {
            margin-left: 20px;
            margin-top: 8px;
        }

        .guidance-content li {
            margin: 6px 0;
        }

        .step-actions {
            margin-top: 12px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .step-actions .btn {
            flex: 1;
            min-width: 140px;
        }

        .hidden {
            display: none;
        }

        /* Utility Classes */
        .mt-20 {
            margin-top: 16px;
        }

        .mb-20 {
            margin-bottom: 16px;
        }

        @media (min-width: 768px) {
            .mt-20 {
                margin-top: 20px;
            }

            .mb-20 {
                margin-bottom: 20px;
            }
        }

        .text-center {
            text-align: center;
        }

        .flex-between {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .gap-10 {
            gap: 10px;
        }

        /* Notification Status Banner */
        .notification-status {
            background: #2a2a1a;
            border: 1px solid #3a3a2a;
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 20px;
            text-align: center;
        }

        .notification-status p {
            color: #e0e0e0;
            margin-bottom: 12px;
            font-size: 0.9em;
        }

        .notification-status.success {
            background: #1a2a1a;
            border-color: #28a745;
        }

        .notification-status.success p {
            color: #90EE90;
        }

        /* Empty state styling */
        .empty-state {
            color: #a0a0a0;
            text-align: center;
            padding: 40px 20px;
            background: #1a1a1a;
            border-radius: 12px;
            border: 1px dashed #2a2a2a;
        }

        /* Scrollbar styling for webkit browsers */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #0f0f0f;
        }

        ::-webkit-scrollbar-thumb {
            background: #2a2a2a;
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #3a3a3a;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üçû Sourdough Timer</h1>

        <!-- Notification Status -->
        <div id="notificationStatus" class="notification-status hidden">
            <p>üì¢ Enable notifications to get alerts when steps are ready</p>
            <button class="btn btn-secondary" onclick="app.requestNotificationPermission()">Enable Notifications</button>
        </div>

        <!-- Active Timer Banner (shown when there are active bakes) -->
        <div id="timerBanner" class="timer-banner hidden" onclick="app.handleBannerClick()">
            <div class="banner-content">
                <h2 id="bannerRecipeName"></h2>
                <div class="current-step" id="bannerCurrentStep"></div>
                <div class="timer-progress-bar">
                    <div class="timer-progress-fill" id="bannerProgressFill"></div>
                </div>
                <div class="time-remaining" id="bannerTimeRemaining"></div>
                <div class="next-step" id="bannerNextStep"></div>
            </div>
        </div>

        <!-- Main Screen -->
        <div id="mainScreen">
            <!-- Active Bakes Section -->
            <div class="active-bakes">
                <div class="flex-between mb-20">
                    <h2>Active Bakes</h2>
                    <button class="btn" onclick="app.showRecipeSelection()">+ Start New Bake</button>
                </div>
                <div id="activeBakesList"></div>
            </div>
        </div>

        <!-- Recipe Selection Screen -->
        <div id="recipeSelection" class="hidden">
            <button class="btn btn-secondary mb-20" onclick="app.showMainScreen()">‚Üê Back</button>
            <h2 class="mb-20">Choose a Recipe</h2>
            <div class="recipe-grid" id="recipeGrid"></div>
        </div>

        <!-- Timeline Setup Screen -->
        <div id="timelineSetup" class="hidden">
            <button class="btn btn-secondary mb-20" onclick="app.showRecipeSelection()">‚Üê Back</button>
            <div class="timeline-setup">
                <h2 id="setupRecipeName" class="mb-20"></h2>
                
                <!-- Mode Selection -->
                <div class="mode-selector">
                    <div class="mode-btn active" data-mode="forward" onclick="app.selectMode('forward')">
                        <h3>Starting Now</h3>
                        <p>Calculate when everything will be ready</p>
                    </div>
                    <div class="mode-btn" data-mode="backward" onclick="app.selectMode('backward')">
                        <h3>Target End Time</h3>
                        <p>Plan when to start for a specific finish</p>
                    </div>
                </div>

                <!-- Time Input -->
                <div class="form-group" id="startTimeGroup">
                    <label for="startTime">Start Time:</label>
                    <input type="datetime-local" id="startTime">
                    <div class="hint">Can be in the past if you've already started</div>
                </div>

                <div class="form-group hidden" id="endTimeGroup">
                    <label for="endTime">When do you want to slice/eat?</label>
                    <input type="datetime-local" id="endTime">
                </div>

                <!-- Starting Step Selector -->
                <div class="step-selector">
                    <h4>Starting from which step?</h4>
                    <select id="startingStep">
                        <option value="0">Beginning (Step 1)</option>
                    </select>
                    <div class="hint">Choose where you are in the process</div>
                </div>

                <!-- Recipe Options -->
                <div id="recipeOptions" class="options-section"></div>

                <button class="btn btn-success mt-20" onclick="app.calculateTimeline()">Calculate Timeline</button>
            </div>
        </div>

        <!-- Timeline View Screen -->
        <div id="timelineView" class="hidden">
            <button class="btn btn-secondary mb-20" onclick="app.showMainScreen()">‚Üê Back to Active Bakes</button>
            
            <div class="timeline-view">
                <div class="flex-between mb-20">
                    <div>
                        <h2 id="timelineRecipeName"></h2>
                        <p id="timelineStartEnd"></p>
                    </div>
                    <button class="btn btn-danger" onclick="app.finishBake()">Finish & Archive</button>
                </div>

                <!-- Ingredients Checklist -->
                <div id="ingredientsSection" class="ingredients-section"></div>

                <!-- Timeline Steps -->
                <div id="timelineSteps"></div>
            </div>
        </div>
    </div>

    <script>
        // Recipe Data
        const RECIPES = {
            sourdough: {
                name: "Sourdough Loaf",
                description: "Classic sourdough bread with cold proof option",
                ingredients: [
                    "Starter (active and healthy)",
                    "Flour",
                    "Water",
                    "Salt"
                ],
                steps: [
                    {
                        name: "Feed starter",
                        duration: { min: 4, max: 8, unit: "hours" },
                        guidance: {
                            visual: ["Wait until starter is at or near peak", "Domed top", "Lots of bubbles", "Noticeably increased volume"],
                            tips: ["Feed the night before you want to bake", "Or whenever fits your day"]
                        }
                    },
                    {
                        name: "Mix dough (autolyse optional)",
                        options: [
                            { name: "With autolyse", duration: 45, unit: "minutes" },
                            { name: "Skip autolyse", duration: 5, unit: "minutes" }
                        ],
                        guidance: {
                            visual: ["Mix flour + water (no salt, no starter yet)", "Rest if doing autolyse"],
                            tips: ["Autolyse helps with gluten development", "If skipping, just mix everything and continue"]
                        }
                    },
                    {
                        name: "Add starter + salt",
                        duration: 15,
                        unit: "minutes",
                        guidance: {
                            visual: ["Mix in starter, then salt", "Add splash of water if needed"],
                            tips: ["Rest for 10-20 minutes after mixing"]
                        }
                    },
                    {
                        name: "Stretch & folds",
                        expandable: true,
                        foldInterval: 30, // minutes between each fold
                        options: [
                            { name: "3 sets", sets: 3 },
                            { name: "4 sets", sets: 4 },
                            { name: "5 sets", sets: 5 }
                        ],
                        guidance: {
                            visual: ["Wet hands, grab one side of dough", "Stretch up and fold over to other side", "Rotate bowl 90¬∞ and repeat 4 times"],
                            tips: ["Use coil folds or stretch and folds", "Handle gently to preserve air", "Each set gets easier as gluten develops"]
                        }
                    },
                    {
                        name: "Bulk fermentation",
                        duration: { min: 2, max: 5, unit: "hours" },
                        guidance: {
                            visual: ["Dough is smoother and airy", "Noticeable rise (~30-75%)", "Bubbles along sides/top", "Jiggly, elastic, not soupy"],
                            tips: ["Very temperature dependent", "Visual cues more reliable than clock", "Don't rush this step"]
                        }
                    },
                    {
                        name: "Pre-shape",
                        duration: 20,
                        unit: "minutes",
                        guidance: {
                            visual: ["Turn out gently", "Shape into loose round", "Bench rest 15-30 minutes"],
                            tips: ["Don't deflate the dough", "Light touch is key"]
                        }
                    },
                    {
                        name: "Final shape + basket",
                        options: [
                            { name: "Room-temp proof (1 hour)", duration: 60, unit: "minutes" },
                            { name: "Cold proof (12 hours)", duration: 720, unit: "minutes" }
                        ],
                        guidance: {
                            visual: ["Shape tightly", "Place in floured basket", "Room-temp: proof until poke test passes", "Cold proof: refrigerate 8-16 hours"],
                            tips: ["Cold proof recommended for scheduling + flavor", "Poke test: slow partial spring-back means ready"]
                        }
                    },
                    {
                        name: "Bake",
                        duration: 50,
                        unit: "minutes",
                        guidance: {
                            visual: ["Preheat oven + Dutch oven 45-60 min", "Bake covered 20 min", "Bake uncovered 20-30 min until deep brown"],
                            tips: ["Score the dough before baking", "Use parchment paper for easy transfer"]
                        }
                    },
                    {
                        name: "Cool",
                        duration: { min: 2, max: 4, unit: "hours" },
                        guidance: {
                            visual: ["Cool on a rack", "Don't cut early - interior still cooking"],
                            tips: ["This is critical for texture", "Be patient!"]
                        }
                    },
                    {
                        name: "Slice & enjoy",
                        duration: 0,
                        unit: "minutes",
                        guidance: {
                            tips: ["Use a serrated bread knife", "Enjoy your hard work!"]
                        }
                    }
                ]
            },
            pizza: {
                name: "Sourdough Discard Pizza",
                description: "2 pizzas with discard + yeast for reliable rise",
                ingredients: [
                    "150g discard (100% hydration)",
                    "75g fresh starter (100% hydration)",
                    "187g all-purpose flour",
                    "87g water total",
                    "8g salt",
                    "10g olive oil",
                    "2-3g active dry yeast",
                    "Optional: pinch of sugar"
                ],
                steps: [
                    {
                        name: "Bloom yeast",
                        duration: 7,
                        unit: "minutes",
                        guidance: {
                            visual: ["Stir yeast into 50g lukewarm water", "Add pinch of sugar (optional)", "Wait until foamy"],
                            tips: ["Water should be lukewarm, not hot", "Foam means yeast is active"]
                        }
                    },
                    {
                        name: "Mix dough",
                        duration: 5,
                        unit: "minutes",
                        guidance: {
                            visual: ["Combine all ingredients", "Mix until no dry flour remains"],
                            tips: ["Remember: 87g total water includes the 50g bloom water"]
                        }
                    },
                    {
                        name: "Rest",
                        duration: 15,
                        unit: "minutes",
                        guidance: {
                            tips: ["Cover and let sit", "Dough will relax"]
                        }
                    },
                    {
                        name: "Brief knead",
                        duration: 3,
                        unit: "minutes",
                        guidance: {
                            tips: ["Just until smoother", "Don't overwork"]
                        }
                    },
                    {
                        name: "Bulk rise",
                        duration: { min: 90, max: 180, unit: "minutes" },
                        guidance: {
                            visual: ["Cover and let rise", "Should be clearly puffy and lighter"],
                            tips: ["Time varies by room temp", "Warmer starter/discard = faster rise"]
                        }
                    },
                    {
                        name: "Divide + ball",
                        duration: 5,
                        unit: "minutes",
                        options: [
                            { name: "Use today", duration: 0, branch: "today" },
                            { name: "Refrigerate (2 days)", duration: 0, branch: "refrigerate" },
                            { name: "Freeze (2 months)", duration: 0, branch: "freeze" }
                        ],
                        guidance: {
                            visual: ["Divide into 2 dough balls", "Lightly oil to prevent sticking", "Cover"],
                            tips: ["Choose your path: today, fridge, or freezer"]
                        }
                    },
                    {
                        name: "Proof dough balls",
                        duration: { min: 60, max: 120, unit: "minutes" },
                        branch: "today",
                        guidance: {
                            visual: ["Let balls proof until puffy and soft", "Should stretch without snapping back hard"],
                            tips: ["Ready when relaxed and stretchy"]
                        }
                    },
                    {
                        name: "Preheat oven",
                        duration: 20,
                        unit: "minutes",
                        branch: "today",
                        guidance: {
                            tips: ["Preheat to 450¬∞F", "Don't leave nonstick pan empty for long"]
                        }
                    },
                    {
                        name: "Shape + top",
                        duration: 15,
                        unit: "minutes",
                        branch: "today",
                        guidance: {
                            visual: ["Shape each to 10-11\" for softer crust", "Transfer to sheet pan (parchment optional)", "Top lightly"],
                            tips: ["Don't overload toppings - keeps it from getting soggy"]
                        }
                    },
                    {
                        name: "Bake",
                        duration: 13,
                        unit: "minutes",
                        branch: "today",
                        guidance: {
                            visual: ["Bake until edges brown and cheese bubbles", "Optional: broil 30-90 sec for more color"],
                            tips: ["Don't overbake - use broil for color instead"]
                        }
                    },
                    {
                        name: "Rest + slice",
                        duration: 4,
                        unit: "minutes",
                        branch: "today",
                        guidance: {
                            tips: ["Rest briefly before slicing", "Improves texture"]
                        }
                    },
                    {
                        name: "Refrigerate dough balls",
                        duration: 1440,
                        unit: "minutes",
                        branch: "refrigerate",
                        guidance: {
                            visual: ["Lightly oil dough balls", "Place in covered containers/bags (airtight)", "Refrigerate up to 24-48 hours"],
                            tips: ["More time = more flavor", "To use: remove 2-3 hours before, proof at room temp until puffy"]
                        }
                    },
                    {
                        name: "Freeze dough balls",
                        duration: 0,
                        unit: "minutes",
                        branch: "freeze",
                        guidance: {
                            visual: ["Lightly oil each ball", "Individual freezer bags (airtight)", "Freeze flat if possible"],
                            tips: ["Best within 1-2 months", "To use: thaw in fridge 12-24 hrs, then room temp proof 1-3 hrs"]
                        }
                    }
                ]
            },
            naan: {
                name: "Garlic Discard Naan",
                description: "4 pieces of soft, garlicky flatbread",
                ingredients: [
                    "240g sourdough discard",
                    "15g olive oil (or melted butter)",
                    "2.5-3.75g fine salt",
                    "10g honey or sugar (optional)",
                    "4g baking powder",
                    "120-180g all-purpose flour",
                    "Garlic butter: 20g butter, 1-2 cloves garlic, pinch salt, optional herbs"
                ],
                steps: [
                    {
                        name: "Mix dough",
                        duration: 3,
                        unit: "minutes",
                        guidance: {
                            visual: ["Mix discard + oil + salt + honey/sugar"],
                            tips: ["Get base mixed well before adding flour"]
                        }
                    },
                    {
                        name: "Add flour",
                        duration: 5,
                        unit: "minutes",
                        guidance: {
                            visual: ["Add 120g flour and mix", "Add more 10-15g at a time only if needed"],
                            tips: ["Stop when soft and slightly tacky", "Not flaky or crumbly"]
                        }
                    },
                    {
                        name: "Rest",
                        duration: 17,
                        unit: "minutes",
                        guidance: {
                            tips: ["Cover and rest 15-20 minutes", "Lets gluten relax"]
                        }
                    },
                    {
                        name: "Add baking powder",
                        duration: 2,
                        unit: "minutes",
                        guidance: {
                            visual: ["Knead/fold in 4g baking powder", "30-45 seconds until evenly combined"],
                            tips: ["This gives the naan its lift"]
                        }
                    },
                    {
                        name: "Divide + shape",
                        duration: 5,
                        unit: "minutes",
                        guidance: {
                            visual: ["Divide into 4 balls", "Roll/press to 3-5mm thick (~1/8-3/16\")", "Keep center slightly thicker than edges"],
                            tips: ["Thicker = softer naan"]
                        }
                    },
                    {
                        name: "Cook",
                        duration: 10,
                        unit: "minutes",
                        guidance: {
                            visual: ["Preheat griddle on high (8/10)", "Cook dry (no butter on surface)", "~60 seconds per side", "Look for bubbles + brown spots"],
                            tips: ["Don't overcook - keep them soft"]
                        }
                    },
                    {
                        name: "Finish with garlic butter",
                        duration: 2,
                        unit: "minutes",
                        guidance: {
                            visual: ["Brush with garlic butter immediately after cooking"],
                            tips: ["Best same-day", "Can store wrapped in fridge 3-4 days or freeze up to 2 months"]
                        }
                    }
                ]
            }
        };

        // Application State
        const app = {
            currentScreen: 'main',
            selectedRecipe: null,
            mode: 'forward',
            activeBakes: [],
            currentBakeId: null,
            timerInterval: null,

            init() {
                this.loadActiveBakes();
                this.renderActiveBakes();
                this.setDefaultStartTime();
                this.startTimerUpdates();
                this.checkNotificationPermission();
            },

            checkNotificationPermission() {
                if (!('Notification' in window)) {
                    return; // Notifications not supported
                }

                const statusEl = document.getElementById('notificationStatus');
                
                if (Notification.permission === 'default') {
                    statusEl.classList.remove('hidden', 'success');
                } else if (Notification.permission === 'granted') {
                    statusEl.classList.remove('hidden');
                    statusEl.classList.add('success');
                    statusEl.innerHTML = '<p>‚úÖ Notifications enabled - you\'ll be alerted when steps are ready</p>';
                } else {
                    statusEl.classList.add('hidden');
                }
            },

            requestNotificationPermission() {
                if ('Notification' in window) {
                    Notification.requestPermission().then(permission => {
                        this.checkNotificationPermission();
                    });
                }
            },

            loadActiveBakes() {
                const saved = localStorage.getItem('activeBakes');
                if (saved) {
                    this.activeBakes = JSON.parse(saved);
                    // Convert date strings back to Date objects
                    this.activeBakes.forEach(bake => {
                        bake.steps.forEach(step => {
                            step.time = new Date(step.time);
                        });
                    });
                }
            },

            saveActiveBakes() {
                localStorage.setItem('activeBakes', JSON.stringify(this.activeBakes));
            },

            populateStartingSteps() {
                const recipe = RECIPES[this.selectedRecipe];
                const select = document.getElementById('startingStep');
                
                select.innerHTML = recipe.steps.map((step, index) => {
                    return `<option value="${index}">${index === 0 ? 'Beginning: ' : 'Skip to: '}${step.name}</option>`;
                }).join('');
            },

            showMainScreen() {
                this.hideAllScreens();
                document.getElementById('mainScreen').classList.remove('hidden');
                this.updateGlobalTimerBanner();
                this.currentScreen = 'main';
            },

            showRecipeSelection() {
                this.hideAllScreens();
                document.getElementById('recipeSelection').classList.remove('hidden');
                this.renderRecipeGrid();
                this.updateGlobalTimerBanner();
                this.currentScreen = 'recipeSelection';
            },

            showTimelineSetup(recipeKey) {
                this.hideAllScreens();
                this.selectedRecipe = recipeKey;
                document.getElementById('timelineSetup').classList.remove('hidden');
                document.getElementById('setupRecipeName').textContent = RECIPES[recipeKey].name;
                this.renderRecipeOptions();
                this.populateStartingSteps();
                this.updateGlobalTimerBanner();
                this.currentScreen = 'timelineSetup';
            },

            showTimelineView(bakeId) {
                this.hideAllScreens();
                this.currentBakeId = bakeId;
                const bake = this.activeBakes.find(b => b.id === bakeId);
                if (!bake) return;

                document.getElementById('timelineView').classList.remove('hidden');
                document.getElementById('timelineRecipeName').textContent = bake.recipeName;
                
                const startTime = new Date(bake.steps[0].time).toLocaleString();
                const endTime = new Date(bake.steps[bake.steps.length - 1].time).toLocaleString();
                document.getElementById('timelineStartEnd').textContent = `${startTime} ‚Üí ${endTime}`;

                this.renderIngredients(bake);
                this.renderTimelineSteps(bake);
                this.updateGlobalTimerBanner();
                this.currentScreen = 'timelineView';
            },

            hideAllScreens() {
                document.getElementById('mainScreen').classList.add('hidden');
                document.getElementById('recipeSelection').classList.add('hidden');
                document.getElementById('timelineSetup').classList.add('hidden');
                document.getElementById('timelineView').classList.add('hidden');
            },

            renderActiveBakes() {
                const container = document.getElementById('activeBakesList');
                if (this.activeBakes.length === 0) {
                    container.innerHTML = '<div class="empty-state">No active bakes. Start a new one!</div>';
                    return;
                }

                container.innerHTML = this.activeBakes.map(bake => {
                    const currentStep = this.getCurrentStep(bake);
                    return `
                        <div class="bake-card">
                            <div class="bake-card-info">
                                <h3>${bake.recipeName}</h3>
                                <p>Current: ${currentStep.name} ‚Ä¢ Started: ${new Date(bake.steps[0].time).toLocaleString()}</p>
                            </div>
                            <div class="bake-card-actions">
                                <button class="btn" onclick="app.showTimelineView('${bake.id}')">Continue</button>
                                <button class="btn btn-danger" onclick="app.finishBake('${bake.id}')">Finish</button>
                            </div>
                        </div>
                    `;
                }).join('');
                
                this.updateGlobalTimerBanner();
            },

            renderRecipeGrid() {
                const container = document.getElementById('recipeGrid');
                container.innerHTML = Object.keys(RECIPES).map(key => {
                    const recipe = RECIPES[key];
                    return `
                        <div class="recipe-card" onclick="app.showTimelineSetup('${key}')">
                            <h3>${recipe.name}</h3>
                            <p>${recipe.description}</p>
                        </div>
                    `;
                }).join('');
            },

            selectMode(mode) {
                this.mode = mode;
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-mode="${mode}"]`).classList.add('active');

                if (mode === 'forward') {
                    document.getElementById('startTimeGroup').classList.remove('hidden');
                    document.getElementById('endTimeGroup').classList.add('hidden');
                } else {
                    document.getElementById('startTimeGroup').classList.add('hidden');
                    document.getElementById('endTimeGroup').classList.remove('hidden');
                }
            },

            setDefaultStartTime() {
                const now = new Date();
                now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
                document.getElementById('startTime').value = now.toISOString().slice(0, 16);
                document.getElementById('endTime').value = now.toISOString().slice(0, 16);
            },

            renderRecipeOptions() {
                const recipe = RECIPES[this.selectedRecipe];
                const container = document.getElementById('recipeOptions');
                
                const optionSteps = recipe.steps.filter(step => step.options);
                if (optionSteps.length === 0) {
                    container.innerHTML = '';
                    return;
                }

                container.innerHTML = '<h3>Options</h3>' + optionSteps.map((step, stepIndex) => {
                    const actualStepIndex = recipe.steps.indexOf(step);
                    return `
                        <div class="option-group">
                            <h4>${step.name}</h4>
                            <div class="radio-group">
                                ${step.options.map((option, optIndex) => `
                                    <div class="radio-option">
                                        <input type="radio" 
                                               name="option_${actualStepIndex}" 
                                               id="option_${actualStepIndex}_${optIndex}"
                                               value="${optIndex}"
                                               ${optIndex === 0 ? 'checked' : ''}>
                                        <label for="option_${actualStepIndex}_${optIndex}">${option.name}</label>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }).join('');
            },

            calculateTimeline() {
                const recipe = RECIPES[this.selectedRecipe];
                const startingStepIndex = parseInt(document.getElementById('startingStep').value);
                let startTime;

                if (this.mode === 'forward') {
                    startTime = new Date(document.getElementById('startTime').value);
                } else {
                    // Backward mode - calculate from end time
                    const endTime = new Date(document.getElementById('endTime').value);
                    const totalDuration = this.calculateTotalDuration(recipe, startingStepIndex);
                    startTime = new Date(endTime - totalDuration);
                }

                // Get selected options
                const selectedOptions = {};
                recipe.steps.forEach((step, index) => {
                    if (step.options) {
                        const selected = document.querySelector(`input[name="option_${index}"]:checked`);
                        if (selected) {
                            selectedOptions[index] = parseInt(selected.value);
                        }
                    }
                });

                // Create bake object
                const bake = {
                    id: Date.now().toString(),
                    recipeKey: this.selectedRecipe,
                    recipeName: recipe.name,
                    mode: this.mode,
                    selectedOptions,
                    ingredientsChecked: {},
                    steps: [],
                    currentStepIndex: 0,
                    startingStepIndex
                };

                // Calculate step times starting from selected step
                let currentTime = new Date(startTime);
                recipe.steps.forEach((step, index) => {
                    // Mark previous steps as completed if starting mid-process
                    const isCompleted = index < startingStepIndex;

                    let duration;

                    // Expandable steps (e.g., stretch & folds) get split into individual sub-steps
                    if (step.expandable && step.options) {
                        const selectedOptionIndex = selectedOptions[index] || 0;
                        const option = step.options[selectedOptionIndex];
                        const numSets = option.sets;
                        const interval = step.foldInterval; // minutes between folds

                        for (let s = 1; s <= numSets; s++) {
                            bake.steps.push({
                                name: `${step.name} (${s}/${numSets})`,
                                time: new Date(currentTime),
                                duration: interval,
                                unit: 'minutes',
                                guidance: step.guidance,
                                completed: isCompleted,
                                selectedOption: option.name,
                                stepIndex: index
                            });
                            currentTime = new Date(currentTime.getTime() + interval * 60 * 1000);
                        }
                    } else if (step.options) {
                        const selectedOptionIndex = selectedOptions[index] || 0;
                        const option = step.options[selectedOptionIndex];
                        duration = option.duration;

                        bake.steps.push({
                            name: step.name,
                            time: new Date(currentTime),
                            duration,
                            unit: option.unit || step.unit,
                            guidance: step.guidance,
                            completed: isCompleted,
                            selectedOption: option.name,
                            branch: option.branch,
                            stepIndex: index
                        });

                        // Advance time
                        if ((option.unit || step.unit) === 'hours') {
                            currentTime = new Date(currentTime.getTime() + duration * 60 * 60 * 1000);
                        } else {
                            currentTime = new Date(currentTime.getTime() + duration * 60 * 1000);
                        }
                    } else {
                        // Handle duration ranges
                        if (typeof step.duration === 'object' && step.duration.min) {
                            duration = (step.duration.min + step.duration.max) / 2;
                        } else {
                            duration = step.duration;
                        }

                        bake.steps.push({
                            name: step.name,
                            time: new Date(currentTime),
                            duration,
                            unit: step.unit,
                            guidance: step.guidance,
                            completed: isCompleted,
                            stepIndex: index
                        });

                        // Advance time
                        if (step.unit === 'hours') {
                            currentTime = new Date(currentTime.getTime() + duration * 60 * 60 * 1000);
                        } else {
                            currentTime = new Date(currentTime.getTime() + duration * 60 * 1000);
                        }
                    }
                });

                this.activeBakes.push(bake);
                this.saveActiveBakes();
                this.showTimelineView(bake.id);
            },

            calculateTotalDuration(recipe, startingStepIndex = 0) {
                let total = 0;
                recipe.steps.forEach((step, index) => {
                    // Skip steps before the starting step
                    if (index < startingStepIndex) return;

                    let duration;

                    if (step.expandable && step.options) {
                        // Expandable steps: sets √ó interval
                        const numSets = step.options[0].sets;
                        total += numSets * step.foldInterval * 60 * 1000;
                    } else if (step.options) {
                        // Use first option as default
                        duration = step.options[0].duration;
                        const unit = step.options[0].unit || step.unit;
                        if (unit === 'hours') {
                            total += duration * 60 * 60 * 1000;
                        } else {
                            total += duration * 60 * 1000;
                        }
                    } else {
                        if (typeof step.duration === 'object' && step.duration.min) {
                            duration = (step.duration.min + step.duration.max) / 2;
                        } else {
                            duration = step.duration;
                        }
                        
                        if (step.unit === 'hours') {
                            total += duration * 60 * 60 * 1000;
                        } else {
                            total += duration * 60 * 1000;
                        }
                    }
                });
                return total;
            },

            renderIngredients(bake) {
                const recipe = RECIPES[bake.recipeKey];
                const container = document.getElementById('ingredientsSection');
                
                container.innerHTML = `
                    <h3>Ingredients Checklist</h3>
                    ${recipe.ingredients.map((ingredient, index) => {
                        const isChecked = bake.ingredientsChecked[index] || false;
                        return `
                            <div class="ingredient-item ${isChecked ? 'checked' : ''}">
                                <input type="checkbox" 
                                       id="ingredient_${index}" 
                                       ${isChecked ? 'checked' : ''}
                                       onchange="app.toggleIngredient('${bake.id}', ${index})">
                                <label for="ingredient_${index}">${ingredient}</label>
                            </div>
                        `;
                    }).join('')}
                `;
            },

            toggleIngredient(bakeId, ingredientIndex) {
                const bake = this.activeBakes.find(b => b.id === bakeId);
                if (!bake) return;

                bake.ingredientsChecked[ingredientIndex] = !bake.ingredientsChecked[ingredientIndex];
                this.saveActiveBakes();
                this.renderIngredients(bake);
            },

            renderTimelineSteps(bake) {
                const container = document.getElementById('timelineSteps');
                const currentStepIndex = this.getCurrentStepIndex(bake);

                container.innerHTML = '<h3>Timeline</h3>' + bake.steps.map((step, index) => {
                    const isCompleted = step.completed;
                    const isActive = index === currentStepIndex && !step.completed;
                    const timeStr = step.time.toLocaleString();
                    const durationStr = step.duration > 0 ?
                        `${step.duration} ${step.unit}` :
                        'Ready';

                    return `
                        <div class="step-card ${isCompleted ? 'completed' : ''} ${isActive ? 'active' : ''}" id="step_${index}">
                            <div class="step-header">
                                <div>
                                    <div class="step-title">${step.name}</div>
                                    ${step.selectedOption ? `<div style="color: #666; font-size: 0.9em;">${step.selectedOption}</div>` : ''}
                                </div>
                                <div class="step-time">${timeStr}</div>
                            </div>
                            <div class="step-duration">${durationStr}</div>
                            
                            ${step.guidance ? `
                                <div class="step-guidance">
                                    <button class="guidance-toggle" onclick="app.toggleGuidance(${index})">
                                        Show guidance ‚ñº
                                    </button>
                                    <div class="guidance-content hidden" id="guidance_${index}">
                                        ${step.guidance.visual ? `
                                            <strong>Visual cues:</strong>
                                            <ul>
                                                ${step.guidance.visual.map(cue => `<li>${cue}</li>`).join('')}
                                            </ul>
                                        ` : ''}
                                        ${step.guidance.tips ? `
                                            <strong>Tips:</strong>
                                            <ul>
                                                ${step.guidance.tips.map(tip => `<li>${tip}</li>`).join('')}
                                            </ul>
                                        ` : ''}
                                    </div>
                                </div>
                            ` : ''}

                            ${isActive && !isCompleted ? `
                                <div class="step-actions">
                                    <button class="btn btn-success" onclick="app.completeStep('${bake.id}', ${index})">
                                        Mark Complete
                                    </button>
                                    ${step.name.includes('fermentation') || step.name.includes('proof') ? `
                                        <button class="btn btn-secondary" onclick="app.adjustStepOptions('${bake.id}', ${index})">
                                            Adjust Options
                                        </button>
                                    ` : ''}
                                </div>
                            ` : ''}
                        </div>
                    `;
                }).join('');
            },

            toggleGuidance(stepIndex) {
                const content = document.getElementById(`guidance_${stepIndex}`);
                const button = content.previousElementSibling;
                
                if (content.classList.contains('hidden')) {
                    content.classList.remove('hidden');
                    button.textContent = 'Hide guidance ‚ñ≤';
                } else {
                    content.classList.add('hidden');
                    button.textContent = 'Show guidance ‚ñº';
                }
            },

            completeStep(bakeId, stepIndex) {
                const bake = this.activeBakes.find(b => b.id === bakeId);
                if (!bake) return;

                bake.steps[stepIndex].completed = true;
                bake.currentStepIndex = stepIndex + 1;
                this.saveActiveBakes();
                this.renderTimelineSteps(bake);
                this.updateGlobalTimerBanner();
            },

            getCurrentStep(bake) {
                for (let i = 0; i < bake.steps.length; i++) {
                    if (!bake.steps[i].completed) {
                        return bake.steps[i];
                    }
                }
                return bake.steps[bake.steps.length - 1];
            },

            getCurrentStepIndex(bake) {
                for (let i = 0; i < bake.steps.length; i++) {
                    if (!bake.steps[i].completed) {
                        return i;
                    }
                }
                return bake.steps.length - 1;
            },

            updateGlobalTimerBanner() {
                // If viewing a specific bake's timeline, show that bake's timer
                if (this.currentScreen === 'timelineView' && this.currentBakeId) {
                    const bake = this.activeBakes.find(b => b.id === this.currentBakeId);
                    if (bake) {
                        this.updatePerBakeTimerBanner(bake);
                        return;
                    }
                }

                // Global mode: remove per-bake styling
                document.getElementById('timerBanner').classList.remove('per-bake');

                // Show banner if there are any active bakes
                if (this.activeBakes.length === 0) {
                    document.getElementById('timerBanner').classList.add('hidden');
                    return;
                }

                // Find the most urgent active bake (closest upcoming step)
                let mostUrgentBake = null;
                let shortestTimeRemaining = Infinity;
                const now = new Date();

                this.activeBakes.forEach(bake => {
                    const currentStepIndex = this.getCurrentStepIndex(bake);
                    const currentStep = bake.steps[currentStepIndex];
                    
                    if (!currentStep.completed) {
                        const timeRemaining = currentStep.time - now;
                        if (timeRemaining < shortestTimeRemaining) {
                            shortestTimeRemaining = timeRemaining;
                            mostUrgentBake = bake;
                        }
                    }
                });

                if (!mostUrgentBake) {
                    document.getElementById('timerBanner').classList.add('hidden');
                    return;
                }

                document.getElementById('timerBanner').classList.remove('hidden');
                const progressFill = document.getElementById('bannerProgressFill');

                const currentStepIndex = this.getCurrentStepIndex(mostUrgentBake);
                const currentStep = mostUrgentBake.steps[currentStepIndex];

                document.getElementById('bannerRecipeName').textContent = mostUrgentBake.recipeName;
                document.getElementById('bannerCurrentStep').textContent = `${mostUrgentBake.recipeName} ‚Äî ${currentStep.name}`;

                // Calculate time remaining until end of current step
                const nextStepIndex = currentStepIndex + 1;
                let timeRemaining;
                let totalStepDuration;

                if (nextStepIndex < mostUrgentBake.steps.length) {
                    const stepEnd = mostUrgentBake.steps[nextStepIndex].time.getTime();
                    const stepStart = currentStep.time.getTime();
                    timeRemaining = stepEnd - now.getTime();
                    totalStepDuration = stepEnd - stepStart;
                } else {
                    // Last step: use its own duration
                    totalStepDuration = currentStep.duration * (currentStep.unit === 'hours' ? 3600000 : 60000);
                    timeRemaining = (currentStep.time.getTime() + totalStepDuration) - now.getTime();
                }

                if (timeRemaining > 0 && totalStepDuration > 0) {
                    const pct = Math.max(0, Math.min(100, (timeRemaining / totalStepDuration) * 100));
                    progressFill.classList.remove('done');
                    progressFill.style.width = `${pct}%`;
                    document.getElementById('bannerTimeRemaining').textContent = this.formatTimeRemaining(timeRemaining);
                    document.getElementById('bannerTimeRemaining').style.color = 'white';
                } else if (!currentStep.completed) {
                    progressFill.classList.add('done');
                    progressFill.style.width = '0%';
                    document.getElementById('bannerTimeRemaining').textContent = 'Ready now!';
                    document.getElementById('bannerTimeRemaining').style.color = '#ffd700';
                } else {
                    progressFill.classList.add('done');
                    progressFill.style.width = '0%';
                    document.getElementById('bannerTimeRemaining').textContent = 'Completed';
                    document.getElementById('bannerTimeRemaining').style.color = '#90EE90';
                }

                if (currentStepIndex < mostUrgentBake.steps.length - 1) {
                    const nextStep = mostUrgentBake.steps[currentStepIndex + 1];
                    document.getElementById('bannerNextStep').textContent =
                        `Next: ${nextStep.name} at ${nextStep.time.toLocaleTimeString()}`;
                } else {
                    document.getElementById('bannerNextStep').textContent = 'Final step!';
                }
            },

            updatePerBakeTimerBanner(bake) {
                const banner = document.getElementById('timerBanner');
                const progressFill = document.getElementById('bannerProgressFill');
                const currentStepIndex = this.getCurrentStepIndex(bake);
                const currentStep = bake.steps[currentStepIndex];
                const now = new Date();

                banner.classList.remove('hidden');
                banner.classList.add('per-bake');

                document.getElementById('bannerRecipeName').textContent = bake.recipeName;
                document.getElementById('bannerCurrentStep').textContent = currentStep.name;

                if (currentStep.completed) {
                    document.getElementById('bannerTimeRemaining').textContent = 'All steps complete!';
                    document.getElementById('bannerTimeRemaining').style.color = '#90EE90';
                    progressFill.classList.add('done');
                    progressFill.style.width = '0%';
                } else {
                    progressFill.classList.remove('done');

                    // Countdown to end of current step (= start of next step)
                    const nextStepIndex = currentStepIndex + 1;
                    let countdownTarget;
                    let totalStepDuration;

                    if (nextStepIndex < bake.steps.length) {
                        const stepEnd = bake.steps[nextStepIndex].time.getTime();
                        const stepStart = currentStep.time.getTime();
                        countdownTarget = stepEnd - now.getTime();
                        totalStepDuration = stepEnd - stepStart;
                    } else {
                        // Last step: count down its own duration from start time
                        totalStepDuration = currentStep.duration * (currentStep.unit === 'hours' ? 3600000 : 60000);
                        countdownTarget = (currentStep.time.getTime() + totalStepDuration) - now.getTime();
                    }

                    if (countdownTarget > 0 && totalStepDuration > 0) {
                        const pct = Math.max(0, Math.min(100, (countdownTarget / totalStepDuration) * 100));
                        progressFill.style.width = `${pct}%`;
                        document.getElementById('bannerTimeRemaining').textContent = this.formatTimeRemaining(countdownTarget);
                        document.getElementById('bannerTimeRemaining').style.color = 'white';
                    } else {
                        progressFill.classList.add('done');
                        progressFill.style.width = '0%';
                        document.getElementById('bannerTimeRemaining').textContent = 'Ready now!';
                        document.getElementById('bannerTimeRemaining').style.color = '#ffd700';
                    }
                }

                // Next step preview
                if (currentStepIndex < bake.steps.length - 1) {
                    const nextStep = bake.steps[currentStepIndex + 1];
                    document.getElementById('bannerNextStep').textContent =
                        `Next: ${nextStep.name} at ${nextStep.time.toLocaleTimeString()}`;
                } else {
                    document.getElementById('bannerNextStep').textContent = 'Final step!';
                }
            },

            getNextActiveBakeId() {
                if (this.activeBakes.length === 0) return null;
                
                // Return the most urgent bake's ID
                const now = new Date();
                let mostUrgentBake = this.activeBakes[0];
                let shortestTimeRemaining = Infinity;

                this.activeBakes.forEach(bake => {
                    const currentStepIndex = this.getCurrentStepIndex(bake);
                    const currentStep = bake.steps[currentStepIndex];
                    
                    if (!currentStep.completed) {
                        const timeRemaining = currentStep.time - now;
                        if (timeRemaining < shortestTimeRemaining) {
                            shortestTimeRemaining = timeRemaining;
                            mostUrgentBake = bake;
                        }
                    }
                });

                return mostUrgentBake.id;
            },

            handleBannerClick() {
                if (this.currentScreen === 'timelineView' && this.currentBakeId) {
                    // Already viewing a bake ‚Äî scroll to the active step
                    const bake = this.activeBakes.find(b => b.id === this.currentBakeId);
                    if (bake) {
                        const activeIndex = this.getCurrentStepIndex(bake);
                        const stepEl = document.getElementById(`step_${activeIndex}`);
                        if (stepEl) {
                            stepEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }
                } else {
                    // On other screens ‚Äî navigate to the most urgent bake
                    const bakeId = this.getNextActiveBakeId();
                    if (bakeId) {
                        this.showTimelineView(bakeId);
                    }
                }
            },

            formatTimeRemaining(ms) {
                const totalSeconds = Math.floor(ms / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;

                if (hours > 0) {
                    return `${hours}h ${minutes}m`;
                }
                return `${minutes}m ${seconds.toString().padStart(2, '0')}s`;
            },

            startTimerUpdates() {
                // Request notification permission on first load
                if ('Notification' in window && Notification.permission === 'default') {
                    Notification.requestPermission();
                }

                this.timerInterval = setInterval(() => {
                    // Always update the global banner
                    this.updateGlobalTimerBanner();

                    // Check all active bakes for notifications
                    this.checkForNotifications();
                }, 1000);
            },

            checkForNotifications() {
                const now = new Date();
                
                this.activeBakes.forEach(bake => {
                    bake.steps.forEach((step, index) => {
                        // Skip if already completed or already notified
                        if (step.completed || step.notified) return;

                        const timeUntil = step.time - now;
                        
                        // If step time has passed, send notification
                        if (timeUntil <= 0) {
                            step.notified = true;
                            this.sendNotification(bake, step, index);
                            this.saveActiveBakes();
                        }
                    });
                });
            },

            sendNotification(bake, step, stepIndex) {
                // Browser notification
                if ('Notification' in window && Notification.permission === 'granted') {
                    const nextStep = bake.steps[stepIndex + 1];
                    const body = nextStep 
                        ? `Time for: ${step.name}\nNext: ${nextStep.name}`
                        : `Time for: ${step.name}\nFinal step!`;

                    const notification = new Notification(`üçû ${bake.recipeName}`, {
                        body: body,
                        icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="75" font-size="75">üçû</text></svg>',
                        tag: `sourdough-${bake.id}-${stepIndex}`,
                        requireInteraction: true,
                        vibrate: [200, 100, 200]
                    });

                    notification.onclick = () => {
                        window.focus();
                        this.showTimelineView(bake.id);
                        notification.close();
                    };
                }

                // Play sound alert
                this.playAlert();
            },

            playAlert() {
                // Create a simple beep sound using Web Audio API
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';

                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                } catch (e) {
                    console.log('Audio not supported');
                }
            },

            adjustStepOptions(bakeId, bakeStepIndex) {
                const bake = this.activeBakes.find(b => b.id === bakeId);
                if (!bake) return;

                const recipe = RECIPES[bake.recipeKey];
                const recipeStepIndex = bake.steps[bakeStepIndex].stepIndex;
                const step = recipe.steps[recipeStepIndex];

                if (!step.options) return;

                // Show options dialog
                const currentOption = bake.selectedOptions[recipeStepIndex] || 0;
                const optionsHtml = step.options.map((option, optIndex) => {
                    return `<option value="${optIndex}" ${optIndex === currentOption ? 'selected' : ''}>${option.name}</option>`;
                }).join('');

                const modal = document.createElement('div');
                modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 20px;';
                modal.innerHTML = `
                    <div style="background: #1a1a1a; padding: 24px; border-radius: 12px; max-width: 400px; width: 100%; border: 1px solid #2a2a2a;">
                        <h3 style="color: #ffffff; margin-bottom: 16px;">Adjust ${step.name}</h3>
                        <select id="optionSelect" style="width: 100%; padding: 12px; background: #0f0f0f; border: 2px solid #2a2a2a; border-radius: 8px; color: #e0e0e0; font-size: 1em; margin-bottom: 16px;">
                            ${optionsHtml}
                        </select>
                        <div style="display: flex; gap: 10px;">
                            <button onclick="app.applyOptionChange('${bakeId}', ${bakeStepIndex})" style="flex: 1; background: #667eea; color: white; border: none; padding: 12px; border-radius: 8px; cursor: pointer; font-size: 1em;">Apply</button>
                            <button onclick="app.closeModal()" style="flex: 1; background: #2a2a2a; color: white; border: none; padding: 12px; border-radius: 8px; cursor: pointer; font-size: 1em;">Cancel</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                this.currentModal = modal;
            },

            applyOptionChange(bakeId, bakeStepIndex) {
                const bake = this.activeBakes.find(b => b.id === bakeId);
                if (!bake) return;

                const newOptionIndex = parseInt(document.getElementById('optionSelect').value);
                const recipe = RECIPES[bake.recipeKey];
                const recipeStepIndex = bake.steps[bakeStepIndex].stepIndex;
                const recipeStep = recipe.steps[recipeStepIndex];
                const newOption = recipeStep.options[newOptionIndex];

                // Update the selected option
                bake.selectedOptions[recipeStepIndex] = newOptionIndex;

                // Update the bake step with new option
                bake.steps[bakeStepIndex].duration = newOption.duration;
                bake.steps[bakeStepIndex].unit = newOption.unit || recipeStep.unit;
                bake.steps[bakeStepIndex].selectedOption = newOption.name;
                bake.steps[bakeStepIndex].branch = newOption.branch;

                // Recalculate times from this step forward through bake steps
                let currentTime = new Date(bake.steps[bakeStepIndex].time);
                for (let i = bakeStepIndex; i < bake.steps.length; i++) {
                    bake.steps[i].time = new Date(currentTime);
                    bake.steps[i].notified = false;

                    const duration = bake.steps[i].duration;
                    const unit = bake.steps[i].unit;
                    if (unit === 'hours') {
                        currentTime = new Date(currentTime.getTime() + duration * 60 * 60 * 1000);
                    } else {
                        currentTime = new Date(currentTime.getTime() + duration * 60 * 1000);
                    }
                }

                this.saveActiveBakes();
                this.closeModal();
                this.showTimelineView(bakeId);
            },

            closeModal() {
                if (this.currentModal) {
                    this.currentModal.remove();
                    this.currentModal = null;
                }
            },

            finishBake(bakeId) {
                const id = bakeId || this.currentBakeId;
                if (!id) return;

                if (confirm('Are you sure you want to finish this bake? This cannot be undone.')) {
                    this.activeBakes = this.activeBakes.filter(b => b.id !== id);
                    this.saveActiveBakes();
                    this.showMainScreen();
                    this.renderActiveBakes();
                }
            }
        };

        // Initialize app on load
        document.addEventListener('DOMContentLoaded', () => {
            app.init();
        });
    </script>
</body>
</html>
