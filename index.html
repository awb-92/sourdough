<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Recipe Sherpa">
    <title>Recipe Sherpa</title>
    <meta name="theme-color" content="#000000">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: -apple-system, 'SF Pro Display', 'SF Pro Text', BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
            background: #000000; color: #FFFFFF; padding: 16px;
            padding-top: calc(16px + env(safe-area-inset-top));
            padding-bottom: calc(80px + env(safe-area-inset-bottom));
            padding-left: calc(16px + env(safe-area-inset-left));
            padding-right: calc(16px + env(safe-area-inset-right));
            font-size: 17px; line-height: 1.47; min-height: 100vh;
            -webkit-font-smoothing: antialiased; overscroll-behavior: contain;
        }

        .container { max-width: 600px; margin: 0 auto; }
        h1 { color: #fff; margin-bottom: 6px; font-size: 34px; font-weight: 700; letter-spacing: 0.37px; }
        @media (min-width: 768px) { body { padding: 20px; } }

        /* â”€â”€â”€ Timer Banner â”€â”€â”€ */
        .timer-banner { position: sticky; top: -1px; background: #1C1C1E; color: white; padding: 14px 16px; border-radius: 16px; margin-bottom: 16px; z-index: 100; cursor: pointer; transition: transform 0.15s; }
        .timer-banner:active { transform: scale(0.96); }
        .timer-banner .banner-content { pointer-events: none; }
        .timer-banner.per-bake { background: #1C1C1E; }
        .timer-banner .banner-top-row { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 4px; }
        .timer-banner h2 { font-size: 13px; font-weight: 500; margin-bottom: 2px; opacity: 0.5; text-transform: uppercase; letter-spacing: 0.06em; }
        .timer-banner .current-step { font-size: 17px; font-weight: 600; }
        .timer-banner .time-remaining { font-size: 15px; font-weight: 600; font-variant-numeric: tabular-nums; color: #8E8E93; text-align: right; flex-shrink: 0; }
        .timer-banner .next-step { opacity: 0.5; font-size: 13px; font-weight: 400; margin-top: 4px; }
        .timer-progress-bar { width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; margin: 8px 0 4px; overflow: hidden; }
        .timer-progress-fill { height: 100%; background: #30D158; border-radius: 2px; transition: width 1s linear; width: 100%; }
        .timer-progress-fill.done { background: #FFD60A; width: 0%; }

        /* â”€â”€â”€ Buttons â”€â”€â”€ */
        .btn { background: #0A84FF; color: white; border: none; padding: 14px 20px; border-radius: 12px; cursor: pointer; font-size: 17px; font-weight: 600; transition: transform 0.1s, opacity 0.15s; min-height: 50px; display: inline-flex; align-items: center; justify-content: center; touch-action: manipulation; }
        .btn:active { transform: scale(0.96); opacity: 0.7; }
        @media (hover: hover) { .btn:hover { opacity: 0.85; } }
        .btn-secondary { background: #2C2C2E; color: #FFFFFF; }
        .btn-danger { background: #FF453A; }
        .btn-success { background: #30D158; color: #000000; }
        .btn-sm { font-size: 13px; padding: 8px 14px; min-height: 34px; }

        /* â”€â”€â”€ iOS Back Button â”€â”€â”€ */
        .back-btn { width: 36px; height: 36px; border-radius: 50%; background: #2C2C2E; border: none; color: #0A84FF; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: transform 0.1s, opacity 0.15s; touch-action: manipulation; flex-shrink: 0; }
        .back-btn:active { transform: scale(0.90); opacity: 0.7; }
        .back-btn svg { width: 18px; height: 18px; fill: none; stroke: #0A84FF; stroke-width: 2.5; stroke-linecap: round; stroke-linejoin: round; }

        /* â”€â”€â”€ Active Bakes â”€â”€â”€ */
        .active-bakes { margin-bottom: 24px; }
        .active-bakes h2, #timelineSteps h3 { font-size: 22px; font-weight: 700; color: #fff; margin-bottom: 12px; letter-spacing: -0.26px; }
        .bake-card { background: #1C1C1E; padding: 16px; border-radius: 16px; margin-bottom: 10px; }
        @media (min-width: 768px) { .bake-card { padding: 20px; display: flex; justify-content: space-between; align-items: center; } }
        .bake-card-info h3 { color: #fff; margin-bottom: 4px; font-size: 17px; font-weight: 600; }
        .bake-card-info p { color: #8E8E93; font-size: 13px; line-height: 1.4; }
        .bake-card-actions { display: flex; gap: 8px; margin-top: 14px; }
        @media (min-width: 768px) { .bake-card-actions { margin-top: 0; gap: 10px; } }

        /* â”€â”€â”€ Recipe Book Card â”€â”€â”€ */
        .recipe-book-card { background: #1C1C1E; border-radius: 16px; padding: 16px; margin-bottom: 24px; }
        .recipe-book-card h2 { font-size: 22px; font-weight: 700; margin-bottom: 12px; }
        .recipe-book-item { display: flex; align-items: center; padding: 12px 0; border-bottom: 0.5px solid rgba(60,60,67,0.36); cursor: pointer; transition: opacity 0.15s; min-height: 44px; }
        .recipe-book-item:last-of-type { border-bottom: none; }
        .recipe-book-item:active { opacity: 0.6; }
        .recipe-book-item-info { flex: 1; }
        .recipe-book-item-info h4 { font-size: 17px; font-weight: 600; color: #fff; }
        .recipe-book-item-info p { font-size: 13px; color: #8E8E93; margin-top: 2px; }
        .recipe-book-item .chevron { color: #8E8E93; font-size: 17px; margin-left: 8px; }

        /* â”€â”€â”€ Recipe Cards â”€â”€â”€ */
        .recipe-grid { display: grid; grid-template-columns: 1fr; gap: 10px; margin-top: 16px; }
        @media (min-width: 600px) { .recipe-grid { grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 12px; } }
        .recipe-card { background: #1C1C1E; padding: 20px; border-radius: 16px; cursor: pointer; transition: transform 0.1s, opacity 0.15s; min-height: 90px; display: flex; flex-direction: column; justify-content: center; }
        .recipe-card:active { transform: scale(0.96); opacity: 0.7; }
        .recipe-card h3 { color: #fff; margin-bottom: 4px; font-size: 17px; font-weight: 600; }
        .recipe-card p { color: #8E8E93; font-size: 15px; line-height: 1.4; }

        /* â”€â”€â”€ Timeline Setup â”€â”€â”€ */
        .timeline-setup { background: #1C1C1E; padding: 20px; border-radius: 16px; overflow: hidden; }
        @media (min-width: 768px) { .timeline-setup { padding: 24px; } }

        /* â”€â”€â”€ iOS Segmented Control â”€â”€â”€ */
        .segmented-control { display: flex; background: #2C2C2E; border-radius: 10px; padding: 2px; margin: 16px 0; position: relative; }
        .segmented-btn { flex: 1; padding: 8px 16px; border: none; border-radius: 8px; cursor: pointer; background: transparent; color: #FFFFFF; font-size: 13px; font-weight: 600; transition: all 0.2s cubic-bezier(0.36, 0.66, 0.04, 1); text-align: center; min-height: 32px; z-index: 1; position: relative; }
        .segmented-btn.active { background: #636366; box-shadow: 0 1px 3px rgba(0,0,0,0.3); }

        .form-group { margin: 16px 0; max-width: 100%; overflow: hidden; }
        .form-group label { display: block; margin-bottom: 8px; color: #8E8E93; font-weight: 500; font-size: 13px; text-transform: uppercase; letter-spacing: 0.02em; }
        .form-group input[type="datetime-local"],
        .form-group input[type="text"],
        .form-group input[type="number"],
        .form-group textarea,
        .form-group select { width: 100%; max-width: 100%; padding: 14px; border: none; border-radius: 12px; font-size: 17px; background: #2C2C2E; color: #FFFFFF; min-height: 50px; box-sizing: border-box; font-family: inherit; }
        .form-group textarea { min-height: 100px; resize: vertical; line-height: 1.5; }
        .form-group input:focus, .form-group textarea:focus, .form-group select:focus { outline: 2px solid #0A84FF; outline-offset: -2px; }
        .form-group .hint { font-size: 13px; color: #8E8E93; margin-top: 6px; }

        /* â”€â”€â”€ Options Section â”€â”€â”€ */
        .options-section { margin: 20px 0; }
        .options-section h3 { color: #fff; margin-bottom: 12px; font-size: 17px; font-weight: 600; }
        .option-group { margin: 10px 0; padding: 16px; background: #2C2C2E; border-radius: 12px; }
        .option-group h4 { color: #FFFFFF; margin-bottom: 10px; font-size: 17px; font-weight: 600; }

        /* â”€â”€â”€ iOS Pill Chips â”€â”€â”€ */
        .pill-group { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
        .pill-chip { display: none; }
        .pill-chip + label { display: inline-flex; align-items: center; padding: 8px 16px; background: #3A3A3C; border-radius: 20px; color: #FFFFFF; font-size: 15px; font-weight: 500; cursor: pointer; transition: all 0.2s; min-height: 36px; }
        .pill-chip:checked + label { background: #0A84FF; color: #FFFFFF; }
        .pill-chip + label:active { transform: scale(0.96); }

        /* â”€â”€â”€ Step Selector â”€â”€â”€ */
        .step-selector { margin: 16px 0; padding: 16px; background: #2C2C2E; border-radius: 12px; }
        .step-selector h4 { color: #FFFFFF; margin-bottom: 10px; font-size: 17px; font-weight: 600; }
        .step-selector select { width: 100%; padding: 12px; background: #1C1C1E; border: none; border-radius: 10px; color: #FFFFFF; font-size: 17px; min-height: 50px; cursor: pointer; }
        .step-selector select:focus { outline: 2px solid #0A84FF; outline-offset: -2px; }
        .step-selector .hint { font-size: 13px; color: #8E8E93; margin-top: 6px; }

        /* â”€â”€â”€ Ingredients â”€â”€â”€ */
        .ingredients-section { background: #1C1C1E; padding: 16px; border-radius: 16px; margin: 16px 0; }
        .ingredients-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .ingredients-header h3 { color: #fff; font-size: 17px; font-weight: 600; }
        .multiplier-control { display: flex; background: #2C2C2E; border-radius: 8px; padding: 2px; }
        .multiplier-btn { padding: 4px 10px; border: none; border-radius: 6px; background: transparent; color: #8E8E93; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s; min-height: 28px; }
        .multiplier-btn.active { background: #636366; color: #FFFFFF; box-shadow: 0 1px 3px rgba(0,0,0,0.3); }
        .multiplier-btn:active { transform: scale(0.92); }
        .ingredient-item { display: flex; align-items: center; gap: 12px; padding: 12px 0; border-bottom: 0.5px solid rgba(60,60,67,0.36); min-height: 44px; }
        .ingredient-item:last-child { border-bottom: none; }
        .ingredient-item label { color: #FFFFFF; cursor: pointer; flex: 1; font-size: 17px; }
        .ingredient-item input[type="checkbox"] { width: 24px; height: 24px; cursor: pointer; accent-color: #30D158; flex-shrink: 0; }
        .ingredient-item.checked label { opacity: 0.4; text-decoration: line-through; color: #8E8E93; }

        /* â”€â”€â”€ Timeline View â”€â”€â”€ */
        .timeline-view { background: transparent; padding: 0; }
        .timeline-view h2 { color: #fff; font-size: 22px; font-weight: 700; }

        .screen-header { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; }
        .screen-header h2 { font-size: 22px; font-weight: 700; flex: 1; }

        /* â”€â”€â”€ Step Card â”€â”€â”€ */
        .step-card { background: #1C1C1E; padding: 16px; border-radius: 14px; margin: 10px 0; transition: all 0.3s cubic-bezier(0.36, 0.66, 0.04, 1); }
        .step-card.completed { opacity: 0.5; }
        .step-card.active { box-shadow: 0 0 0 2px #FFFFFF; }
        .step-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 4px; gap: 12px; }
        .step-title { font-size: 17px; font-weight: 600; color: #fff; line-height: 1.3; flex: 1; }
        .info-btn { width: 24px; height: 24px; border-radius: 50%; background: transparent; border: 1.5px solid #8E8E93; color: #8E8E93; font-size: 14px; font-weight: 600; font-style: italic; font-family: Georgia, serif; cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: all 0.2s; padding: 0; line-height: 1; }
        .info-btn.active { background: #0A84FF; border-color: #0A84FF; color: #FFFFFF; }
        .info-btn:active { transform: scale(0.90); }
        .step-time { color: #8E8E93; font-weight: 500; font-size: 13px; text-align: right; flex-shrink: 0; font-variant-numeric: tabular-nums; }
        .step-duration { color: #8E8E93; font-size: 13px; margin: 2px 0; }
        .step-guidance { margin-top: 0; }
        .guidance-content { margin-top: 10px; padding: 14px; background: #2C2C2E; border-radius: 12px; font-size: 15px; line-height: 1.6; color: #EBEBF5; animation: expandIn 0.25s cubic-bezier(0.36, 0.66, 0.04, 1); }
        @keyframes expandIn { from { opacity: 0; max-height: 0; padding: 0 14px; margin-top: 0; } to { opacity: 1; max-height: 500px; padding: 14px; margin-top: 10px; } }
        .guidance-content strong { color: #fff; }
        .guidance-content ul { margin-left: 18px; margin-top: 6px; }
        .guidance-content li { margin: 4px 0; }

        /* â”€â”€â”€ iOS Toggle Slider â”€â”€â”€ */
        .step-toggle-row { display: flex; align-items: center; justify-content: space-between; margin-top: 14px; }
        .step-toggle-label { font-size: 15px; color: #8E8E93; font-weight: 500; }
        .ios-toggle { position: relative; width: 51px; height: 31px; flex-shrink: 0; }
        .ios-toggle input { opacity: 0; width: 0; height: 0; }
        .ios-toggle .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background: #39393D; border-radius: 31px; transition: background 0.3s; }
        .ios-toggle .slider::before { content: ''; position: absolute; height: 27px; width: 27px; left: 2px; bottom: 2px; background: white; border-radius: 50%; transition: transform 0.3s cubic-bezier(0.36, 0.66, 0.04, 1); box-shadow: 0 1px 3px rgba(0,0,0,0.3); }
        .ios-toggle input:checked + .slider { background: #30D158; }
        .ios-toggle input:checked + .slider::before { transform: translateX(20px); }

        .step-actions { margin-top: 14px; display: flex; gap: 10px; flex-wrap: wrap; }
        .step-actions .btn { flex: 1; min-width: 130px; }
        .hidden { display: none; }
        .mt-20 { margin-top: 16px; }
        .mb-20 { margin-bottom: 16px; }
        .text-center { text-align: center; }
        .flex-between { display: flex; justify-content: space-between; align-items: center; gap: 12px; flex-wrap: wrap; }

        /* â”€â”€â”€ Notification Status â”€â”€â”€ */
        .notification-status { padding: 10px 16px; border-radius: 12px; text-align: center; margin-top: 24px; }
        .notification-status p { color: #8E8E93; font-size: 13px; margin-bottom: 8px; }
        .notification-status .btn { font-size: 13px; padding: 8px 16px; min-height: 34px; background: #2C2C2E; }
        .notification-status.success { background: transparent; }
        .notification-status.success p { color: #30D158; font-size: 13px; }
        .empty-state { color: #8E8E93; text-align: center; padding: 40px 20px; background: #1C1C1E; border-radius: 16px; font-size: 17px; opacity: 0.6; }
        .screen-enter { animation: screenSlideIn 0.35s cubic-bezier(0.36, 0.66, 0.04, 1); }
        @keyframes screenSlideIn { from { opacity: 0; transform: translateX(30px); } to { opacity: 1; transform: translateX(0); } }

        /* â”€â”€â”€ Choice Cards â”€â”€â”€ */
        .choice-cards { display: flex; flex-direction: column; gap: 8px; margin-top: 10px; }
        .choice-card { background: #2C2C2E; border-radius: 12px; padding: 14px 16px; cursor: pointer; transition: transform 0.1s, opacity 0.15s; display: flex; align-items: center; gap: 12px; }
        .choice-card:active { transform: scale(0.96); opacity: 0.7; }
        .choice-card-icon { font-size: 24px; flex-shrink: 0; }
        .choice-card-text h4 { font-size: 17px; font-weight: 600; color: #FFFFFF; margin-bottom: 2px; }
        .choice-card-text p { font-size: 13px; color: #8E8E93; }

        /* â”€â”€â”€ Frozen Input â”€â”€â”€ */
        .frozen-input-section { margin-top: 10px; padding: 14px; background: #2C2C2E; border-radius: 12px; }
        .frozen-input-section label { font-size: 13px; color: #8E8E93; text-transform: uppercase; letter-spacing: 0.02em; display: block; margin-bottom: 8px; }
        .frozen-input-section input { width: 100%; padding: 12px; background: #1C1C1E; border: none; border-radius: 10px; color: #FFFFFF; font-size: 17px; min-height: 44px; }
        .frozen-input-section .btn { margin-top: 10px; width: 100%; }

        /* â”€â”€â”€ Toast â”€â”€â”€ */
        .notification-toast { position: fixed; top: calc(env(safe-area-inset-top) + 8px); left: 16px; right: 16px; background: rgba(44,44,46,0.95); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 16px; padding: 14px 16px; z-index: 2000; animation: slideDown 0.4s cubic-bezier(0.36, 0.66, 0.04, 1); box-shadow: 0 4px 20px rgba(0,0,0,0.4); }
        @keyframes slideDown { from { transform: translateY(-100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .notification-toast-title { font-size: 15px; font-weight: 600; margin-bottom: 2px; }
        .notification-toast-body { font-size: 13px; color: #8E8E93; }

        /* â”€â”€â”€ Recipe Detail View â”€â”€â”€ */
        .recipe-detail-card { background: #1C1C1E; border-radius: 16px; padding: 16px; margin-bottom: 12px; }
        .recipe-detail-card h3 { font-size: 17px; font-weight: 600; margin-bottom: 10px; }
        .recipe-detail-card .note { font-size: 13px; color: #8E8E93; padding: 10px; background: #2C2C2E; border-radius: 10px; margin-top: 8px; }
        .recipe-detail-step { padding: 12px 0; border-bottom: 0.5px solid rgba(60,60,67,0.36); }
        .recipe-detail-step:last-child { border-bottom: none; }
        .recipe-detail-step h4 { font-size: 17px; font-weight: 600; }
        .recipe-detail-step .step-meta { font-size: 13px; color: #8E8E93; margin-top: 2px; }
        .recipe-detail-branch-label { font-size: 13px; font-weight: 600; color: #0A84FF; text-transform: uppercase; letter-spacing: 0.04em; padding: 14px 0 4px; margin-top: 4px; }
        .recipe-detail-step .step-visual { font-size: 13px; color: #EBEBF5; margin-top: 4px; line-height: 1.5; }
        .recipe-detail-step .step-visual li { margin: 2px 0; }
        .recipe-detail-step .step-tips { font-size: 13px; color: #8E8E93; margin-top: 4px; line-height: 1.5; }

        /* â”€â”€â”€ Add Recipe Form â”€â”€â”€ */
        .add-step-card { background: #2C2C2E; border-radius: 12px; padding: 14px; margin-bottom: 10px; }
        .add-step-card .form-group { margin: 8px 0; }
        .add-step-card .form-group input, .add-step-card .form-group textarea, .add-step-card .form-group select { background: #1C1C1E; }
        .add-step-row { display: flex; gap: 8px; }
        .add-step-row .form-group { flex: 1; }
        .remove-step-btn { background: none; border: none; color: #FF453A; font-size: 13px; cursor: pointer; padding: 4px 0; margin-top: 4px; }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #3A3A3C; border-radius: 3px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Recipe Sherpa</h1>

        <div id="timerBanner" class="timer-banner hidden" onclick="app.handleBannerClick()">
            <div class="banner-content">
                <div class="banner-top-row">
                    <div>
                        <h2 id="bannerRecipeName"></h2>
                        <div class="current-step" id="bannerCurrentStep"></div>
                    </div>
                    <div class="time-remaining" id="bannerTimeRemaining"></div>
                </div>
                <div class="timer-progress-bar">
                    <div class="timer-progress-fill" id="bannerProgressFill"></div>
                </div>
                <div class="next-step" id="bannerNextStep"></div>
            </div>
        </div>

        <!-- Main Screen -->
        <div id="mainScreen">
            <div class="active-bakes">
                <div class="flex-between mb-20">
                    <h2>Active Bakes</h2>
                    <button class="btn" onclick="app.showRecipeSelection()">+ Start New Bake</button>
                </div>
                <div id="activeBakesList"></div>
            </div>
            <div id="recipeBookCard" class="recipe-book-card"></div>
            <div id="notificationStatus" class="notification-status hidden">
                <p>Enable notifications to get alerts when steps are ready</p>
                <button class="btn btn-secondary" onclick="app.requestNotificationPermission()">Enable Notifications</button>
            </div>
        </div>

        <!-- Recipe Selection Screen -->
        <div id="recipeSelection" class="hidden">
            <div class="screen-header">
                <button class="back-btn" onclick="app.showMainScreen()"><svg viewBox="0 0 24 24"><polyline points="15 18 9 12 15 6"></polyline></svg></button>
                <h2>Choose a Recipe</h2>
            </div>
            <div class="recipe-grid" id="recipeGrid"></div>
        </div>

        <!-- Timeline Setup Screen -->
        <div id="timelineSetup" class="hidden">
            <div class="screen-header">
                <button class="back-btn" onclick="app.showRecipeSelection()"><svg viewBox="0 0 24 24"><polyline points="15 18 9 12 15 6"></polyline></svg></button>
                <h2 id="setupRecipeName"></h2>
            </div>
            <div class="timeline-setup">
                <div class="segmented-control">
                    <button class="segmented-btn active" data-mode="forward" onclick="app.selectMode('forward')">Starting Now</button>
                    <button class="segmented-btn" data-mode="backward" onclick="app.selectMode('backward')">Target End Time</button>
                </div>
                <div class="form-group" id="startTimeGroup">
                    <label for="startTime">Start Time</label>
                    <input type="datetime-local" id="startTime">
                    <div class="hint">Can be in the past if you've already started</div>
                </div>
                <div class="form-group hidden" id="endTimeGroup">
                    <label for="endTime">When do you want to eat?</label>
                    <input type="datetime-local" id="endTime">
                </div>
                <div class="step-selector">
                    <h4>Starting from which step?</h4>
                    <select id="startingStep"><option value="0">Beginning (Step 1)</option></select>
                    <div class="hint">Choose where you are in the process</div>
                </div>
                <div id="recipeOptions" class="options-section"></div>
                <button class="btn btn-success mt-20" style="width:100%" onclick="app.calculateTimeline()">Calculate Timeline</button>
            </div>
        </div>

        <!-- Timeline View Screen -->
        <div id="timelineView" class="hidden">
            <div class="screen-header">
                <button class="back-btn" onclick="app.showMainScreen()"><svg viewBox="0 0 24 24"><polyline points="15 18 9 12 15 6"></polyline></svg></button>
                <div style="flex: 1;">
                    <h2 id="timelineRecipeName"></h2>
                    <p id="timelineStartEnd" style="color: #8E8E93; font-size: 13px; margin-top: 2px;"></p>
                </div>
                <button class="btn btn-danger btn-sm" onclick="app.finishBake()">Finish</button>
            </div>
            <div class="timeline-view">
                <div id="ingredientsSection" class="ingredients-section"></div>
                <div id="timelineSteps"></div>
            </div>
        </div>

        <!-- Recipe Detail View -->
        <div id="recipeDetailView" class="hidden">
            <div class="screen-header">
                <button class="back-btn" onclick="app.showMainScreen()"><svg viewBox="0 0 24 24"><polyline points="15 18 9 12 15 6"></polyline></svg></button>
                <h2 id="recipeDetailName"></h2>
            </div>
            <div id="recipeDetailContent"></div>
        </div>

        <!-- Add Recipe Screen -->
        <div id="addRecipeScreen" class="hidden">
            <div class="screen-header">
                <button class="back-btn" onclick="app.showMainScreen()"><svg viewBox="0 0 24 24"><polyline points="15 18 9 12 15 6"></polyline></svg></button>
                <h2>New Recipe</h2>
            </div>
            <div class="form-group">
                <label>Recipe Name</label>
                <input type="text" id="newRecipeName" placeholder="e.g. Focaccia">
            </div>
            <div class="form-group">
                <label>Description</label>
                <input type="text" id="newRecipeDesc" placeholder="Short description">
            </div>
            <div class="form-group">
                <label>Ingredients (one per line)</label>
                <textarea id="newRecipeIngredients" placeholder="500g flour&#10;350g water&#10;10g salt"></textarea>
            </div>
            <h3 style="font-size:17px;font-weight:600;margin:16px 0 10px;">Steps</h3>
            <div id="newRecipeSteps"></div>
            <button class="btn btn-secondary mt-20" style="width:100%" onclick="app.addNewStepField()">+ Add Step</button>
            <button class="btn btn-success mt-20" style="width:100%" onclick="app.saveCustomRecipe()">Save Recipe</button>
        </div>
    </div>

    <script>
        const RECIPES = {
            sourdough: {
                name: "Sourdough Bread (Dutch Oven)",
                description: "Classic sourdough bread for a 5.5 qt Dutch oven",
                note: "Makes ~960g dough. If using mostly AP flour, you may prefer 325-340g water.",
                ingredients: [
                    "500g bread flour (or AP)",
                    "350g water (70% hydration)",
                    "100g active starter (at/near peak)",
                    "10g salt"
                ],
                steps: [
                    {
                        name: "Mix",
                        duration: 5, unit: "minutes",
                        guidance: {
                            visual: ["Mix 350g water + 100g starter until cloudy", "Add 500g flour, mix until no dry flour remains", "Cover"],
                            tips: ["If dough feels stiff, hold back 10-25g water and add only if needed"]
                        }
                    },
                    {
                        name: "Autolyse (optional)",
                        options: [
                            { name: "With autolyse (25 min)", duration: 25, unit: "minutes" },
                            { name: "Skip autolyse", duration: 0, unit: "minutes" }
                        ],
                        guidance: { tips: ["Rest covered", "Helps with gluten development"] }
                    },
                    {
                        name: "Add salt",
                        duration: 3, unit: "minutes",
                        guidance: {
                            visual: ["Sprinkle in 10g salt", "Pinch/fold until incorporated"],
                            tips: ["If dough feels stiff, wet your hand and add a splash of held-back water"]
                        }
                    },
                    {
                        name: "Stretch & folds",
                        expandable: true, foldInterval: 30,
                        options: [
                            { name: "3 sets", sets: 3 },
                            { name: "4 sets", sets: 4 },
                            { name: "5 sets", sets: 5 }
                        ],
                        guidance: {
                            visual: ["Wet hands, grab one side of dough", "Stretch up and fold over to other side", "Rotate bowl 90Â° and repeat 4 times", "Then let dough rest until next set"],
                            tips: ["Handle gently to preserve air", "Each set gets easier as gluten develops", "After last set, let dough sit until bulk is done"]
                        }
                    },
                    {
                        name: "Bulk fermentation",
                        duration: { min: 3, max: 6, unit: "hours" },
                        guidance: {
                            visual: ["Dough looks puffier and smoother", "Jiggly, with bubbles on sides/top", "Total rise roughly 30-70% (not necessarily doubled)"],
                            tips: ["Very temperature dependent", "Avoid oven light if it overheats â€” find a reliably warm spot", "Visual cues more reliable than clock"]
                        }
                    },
                    {
                        name: "Pre-shape + bench rest",
                        duration: 20, unit: "minutes",
                        guidance: {
                            visual: ["Turn dough onto unfloured or lightly floured surface", "Shape into a loose round", "Rest uncovered 15-25 minutes"],
                            tips: ["Light touch â€” don't deflate the dough"]
                        }
                    },
                    {
                        name: "Final shape",
                        duration: 5, unit: "minutes",
                        guidance: {
                            visual: ["Shape into a tight boule (round)", "Place seam-side up in floured banneton/towel-lined bowl"],
                            tips: ["Tighter shaping = better oven spring"]
                        },
                        postProofChoice: true
                    },
                    {
                        name: "Preheat",
                        duration: 55, unit: "minutes", branch: "today",
                        guidance: {
                            visual: ["Put Dutch oven + lid in oven", "Preheat to 500Â°F for 45-60 min"],
                            tips: ["Make sure Dutch oven is fully preheated"]
                        }
                    },
                    {
                        name: "Score + load",
                        duration: 5, unit: "minutes", branch: "today",
                        guidance: {
                            visual: ["Turn dough onto parchment (seam-side down)", "Score 1 main slash about 1/2\" deep", "Carefully lower into hot Dutch oven, lid on"],
                            tips: ["Work quickly to retain heat"]
                        }
                    },
                    {
                        name: "Bake",
                        duration: 45, unit: "minutes", branch: "today",
                        guidance: {
                            visual: ["20 min @ 500Â°F lid on", "Reduce to 450Â°F", "20-25 min lid off until deep brown"],
                            tips: ["Target: deep golden to dark brown crust", "Internal temp ~205-210Â°F if you check"]
                        }
                    },
                    {
                        name: "Cool",
                        duration: { min: 2, max: 4, unit: "hours" }, branch: "today",
                        guidance: {
                            visual: ["Cool on rack at least 2 hours before slicing"],
                            tips: ["Interior is still cooking â€” be patient!"]
                        }
                    },
                    {
                        name: "Slice & enjoy",
                        duration: 0, unit: "minutes", branch: "today",
                        guidance: { tips: ["Use a serrated bread knife"] }
                    },
                    {
                        name: "Cold proof",
                        duration: 720, unit: "minutes", branch: "cold",
                        guidance: {
                            visual: ["Cover and refrigerate 8-16 hours"],
                            tips: ["Better flavor and easier scoring", "Can bake straight from fridge"]
                        }
                    }
                ]
            },
            pizza: {
                name: "Sourdough Discard Pizza",
                description: "2 pizzas with discard + yeast for reliable rise",
                ingredients: [
                    "150g discard (100% hydration)",
                    "75g fresh starter (100% hydration)",
                    "187g all-purpose flour",
                    "87g water total",
                    "8g salt",
                    "10g olive oil",
                    "2-3g active dry yeast",
                    "Optional: pinch of sugar"
                ],
                note: "Water note: the 50g used to bloom yeast counts toward the 87g total.",
                steps: [
                    {
                        name: "Bloom yeast", duration: 7, unit: "minutes",
                        guidance: {
                            visual: ["Stir 2-3g active dry yeast into 50g lukewarm water", "Optional: add a pinch of sugar", "Wait until foamy"],
                            tips: ["Water should be lukewarm, not hot", "Foam means yeast is active", "This water counts toward the 87g total"]
                        }
                    },
                    {
                        name: "Mix dough", duration: 5, unit: "minutes",
                        guidance: {
                            visual: ["Combine discard, starter, flour, bloomed yeast water, remaining 37g water, salt, olive oil", "Mix until no dry flour remains"],
                            tips: ["87g total water = 50g bloom + 37g remaining", "If dough feels tight, add +5-10g water"]
                        }
                    },
                    {
                        name: "Rest", duration: 15, unit: "minutes",
                        guidance: { tips: ["Cover and let sit", "Dough will relax"] }
                    },
                    {
                        name: "Brief knead", duration: 3, unit: "minutes",
                        guidance: { tips: ["Just until smoother", "Don't overwork"] }
                    },
                    {
                        name: "Bulk rise", duration: { min: 90, max: 180, unit: "minutes" },
                        guidance: {
                            visual: ["Cover and let rise", "Should be clearly puffy and lighter"],
                            tips: ["Time varies by room temp", "Warmer starter/discard = faster rise"]
                        }
                    },
                    {
                        name: "Divide + ball", duration: 5, unit: "minutes",
                        guidance: {
                            visual: ["Divide into 2 dough balls", "Lightly oil to prevent sticking", "Cover"],
                            tips: ["Shape into tight balls for better structure"]
                        }
                    },
                    {
                        name: "Proof dough balls", duration: { min: 60, max: 120, unit: "minutes" },
                        guidance: {
                            visual: ["Let balls proof until puffy and soft", "Should stretch without snapping back hard"],
                            tips: ["Ready when relaxed and stretchy", "Move on to bake, fridge, or freeze after this"]
                        },
                        postProofChoice: true
                    },
                    {
                        name: "Preheat oven", duration: 20, unit: "minutes", branch: "today",
                        guidance: { tips: ["Preheat to 450Â°F", "Don't leave nonstick pan empty for long"] }
                    },
                    {
                        name: "Shape + top", duration: 15, unit: "minutes", branch: "today",
                        guidance: {
                            visual: ["Shape each to 10-11\" for softer crust", "Transfer to sheet pan (parchment optional)", "Top lightly"],
                            tips: ["Don't overload toppings â€” keeps it from getting soggy", "Keep pizzas at 10-11\" (thicker = softer)"]
                        }
                    },
                    {
                        name: "Bake", duration: 13, unit: "minutes", branch: "today",
                        guidance: {
                            visual: ["Bake until edges brown and cheese bubbles", "Optional: broil 30-90 sec for more color"],
                            tips: ["Don't overbake â€” use broil for color instead"]
                        }
                    },
                    {
                        name: "Rest + slice", duration: 4, unit: "minutes", branch: "today",
                        guidance: { tips: ["Rest briefly before slicing", "Improves texture"] }
                    },
                    {
                        name: "Refrigerate dough balls", duration: 1440, unit: "minutes", branch: "refrigerate",
                        guidance: {
                            visual: ["Lightly oil dough balls", "Place in covered containers/bags (airtight)", "Refrigerate up to 24-48 hours"],
                            tips: ["More time = more flavor", "To use: remove 2-3 hours before, proof at room temp until puffy"]
                        }
                    },
                    {
                        name: "Freeze dough balls", duration: 0, unit: "minutes", branch: "freeze",
                        guidance: {
                            visual: ["Lightly oil each ball", "Individual freezer bags (airtight)", "Freeze flat if possible"],
                            tips: ["Best within 1-2 months", "To use: thaw in fridge 12-24 hrs, then room temp proof 1-3 hrs"]
                        }
                    }
                ]
            },
            naan: {
                name: "Garlic Discard Naan",
                description: "4 pieces of soft, garlicky flatbread",
                ingredients: [
                    "240g sourdough discard",
                    "15g olive oil (or melted butter)",
                    "2.5-3.75g fine salt",
                    "10g honey or sugar (optional)",
                    "4g baking powder",
                    "120-180g all-purpose flour",
                    "Garlic butter: 20g butter, 1-2 cloves garlic, pinch salt, optional herbs"
                ],
                steps: [
                    {
                        name: "Mix dough", duration: 3, unit: "minutes",
                        guidance: {
                            visual: ["Mix discard + oil + salt + honey/sugar"],
                            tips: ["Get base mixed well before adding flour"]
                        }
                    },
                    {
                        name: "Add flour", duration: 5, unit: "minutes",
                        guidance: {
                            visual: ["Add 120g flour and mix", "Add more 10-15g at a time only if needed"],
                            tips: ["Stop when soft and slightly tacky", "Not flaky or crumbly"]
                        }
                    },
                    {
                        name: "Rest", duration: 17, unit: "minutes",
                        guidance: { tips: ["Cover and rest 15-20 minutes", "Lets gluten relax"] }
                    },
                    {
                        name: "Add baking powder", duration: 2, unit: "minutes",
                        guidance: {
                            visual: ["Knead/fold in 4g baking powder", "30-45 seconds until evenly combined"],
                            tips: ["This gives the naan its lift"]
                        }
                    },
                    {
                        name: "Divide + shape", duration: 5, unit: "minutes",
                        guidance: {
                            visual: ["Divide into 4 balls", "Roll/press to 3-5mm thick", "Keep center slightly thicker than edges"],
                            tips: ["Thicker = softer naan"]
                        }
                    },
                    {
                        name: "Cook", duration: 10, unit: "minutes",
                        guidance: {
                            visual: ["Preheat griddle on high (8/10)", "Cook dry (no butter on surface)", "~60 seconds per side", "Look for bubbles + brown spots"],
                            tips: ["Don't overcook â€” keep them soft"]
                        }
                    },
                    {
                        name: "Finish with garlic butter", duration: 2, unit: "minutes",
                        guidance: {
                            visual: ["Brush with garlic butter immediately after cooking"],
                            tips: ["Best same-day", "Fridge: wrapped tightly, 3-4 days", "Freezer: parchment between pieces, up to 2 months"]
                        }
                    }
                ]
            }
        };

        const app = {
            currentScreen: 'main',
            selectedRecipe: null,
            mode: 'forward',
            activeBakes: [],
            customRecipes: {},
            currentBakeId: null,
            timerInterval: null,
            newStepCount: 0,

            init() {
                this.loadActiveBakes();
                this.loadCustomRecipes();
                this.renderActiveBakes();
                this.renderRecipeBook();
                this.setDefaultStartTime();
                this.startTimerUpdates();
                this.checkNotificationPermission();
            },

            getRecipes() {
                return { ...RECIPES, ...this.customRecipes };
            },

            loadCustomRecipes() {
                const saved = localStorage.getItem('customRecipes');
                if (saved) this.customRecipes = JSON.parse(saved);
            },

            saveCustomRecipes() {
                localStorage.setItem('customRecipes', JSON.stringify(this.customRecipes));
            },

            checkNotificationPermission() {
                if (!('Notification' in window)) return;
                const el = document.getElementById('notificationStatus');
                if (Notification.permission === 'default') {
                    el.classList.remove('hidden', 'success');
                } else if (Notification.permission === 'granted') {
                    el.classList.remove('hidden');
                    el.classList.add('success');
                    el.innerHTML = '<p>Notifications enabled</p>';
                } else {
                    el.classList.add('hidden');
                }
            },

            requestNotificationPermission() {
                if ('Notification' in window) {
                    Notification.requestPermission().then(() => this.checkNotificationPermission());
                }
            },

            loadActiveBakes() {
                const saved = localStorage.getItem('activeBakes');
                if (saved) {
                    this.activeBakes = JSON.parse(saved);
                    this.activeBakes.forEach(bake => {
                        bake.steps.forEach(step => {
                            step.time = new Date(step.time);
                            if (step.completedAt) step.completedAt = new Date(step.completedAt);
                        });
                    });
                }
            },

            saveActiveBakes() {
                localStorage.setItem('activeBakes', JSON.stringify(this.activeBakes));
            },

            populateStartingSteps() {
                const recipes = this.getRecipes();
                const recipe = recipes[this.selectedRecipe];
                const select = document.getElementById('startingStep');
                // Main (non-branch) steps
                const mainSteps = recipe.steps.filter(s => !s.branch).map((step, index) => {
                    const realIdx = recipe.steps.indexOf(step);
                    return `<option value="${realIdx}">${index === 0 ? 'Beginning: ' : 'Skip to: '}${step.name}</option>`;
                });
                // Branch steps that make sense as starting points (e.g. baking steps after fridge/freeze)
                // Group by branch and find the first step of each "bake day" branch (typically "today")
                const branches = {};
                recipe.steps.forEach((step, i) => {
                    if (step.branch) {
                        if (!branches[step.branch]) branches[step.branch] = [];
                        branches[step.branch].push({ step, index: i });
                    }
                });
                const branchOptions = [];
                // "today" branch = bake day steps (e.g. Preheat, Shape, Bake)
                if (branches['today'] && branches['today'].length > 0) {
                    const first = branches['today'][0];
                    branchOptions.push(`<option value="${first.index}">From fridge/freeze: ${first.step.name}</option>`);
                }
                select.innerHTML = mainSteps.join('') + branchOptions.join('');
            },

            hideAllScreens() {
                ['mainScreen', 'recipeSelection', 'timelineSetup', 'timelineView', 'recipeDetailView', 'addRecipeScreen'].forEach(id => {
                    const el = document.getElementById(id);
                    el.classList.add('hidden');
                    el.classList.remove('screen-enter');
                });
            },

            showMainScreen() {
                this.hideAllScreens();
                document.getElementById('mainScreen').classList.remove('hidden');
                this.renderActiveBakes();
                this.renderRecipeBook();
                this.updateGlobalTimerBanner();
                this.currentScreen = 'main';
            },

            showRecipeSelection() {
                this.hideAllScreens();
                const el = document.getElementById('recipeSelection');
                el.classList.remove('hidden');
                el.classList.add('screen-enter');
                this.renderRecipeGrid();
                this.updateGlobalTimerBanner();
                this.currentScreen = 'recipeSelection';
            },

            showTimelineSetup(recipeKey) {
                this.hideAllScreens();
                this.selectedRecipe = recipeKey;
                const el = document.getElementById('timelineSetup');
                el.classList.remove('hidden');
                el.classList.add('screen-enter');
                const recipes = this.getRecipes();
                document.getElementById('setupRecipeName').textContent = recipes[recipeKey].name;
                this.renderRecipeOptions();
                this.populateStartingSteps();
                this.setDefaultStartTime();
                this.updateGlobalTimerBanner();
                this.currentScreen = 'timelineSetup';
            },

            showTimelineView(bakeId) {
                this.hideAllScreens();
                this.currentBakeId = bakeId;
                const bake = this.activeBakes.find(b => b.id === bakeId);
                if (!bake) return;
                const el = document.getElementById('timelineView');
                el.classList.remove('hidden');
                el.classList.add('screen-enter');
                document.getElementById('timelineRecipeName').textContent = bake.recipeName;
                const st = this.fmtDT(new Date(bake.steps[0].time));
                const en = this.fmtDT(new Date(bake.steps[bake.steps.length - 1].time));
                document.getElementById('timelineStartEnd').textContent = `${st} â†’ ${en}`;
                this.renderIngredients(bake);
                this.renderTimelineSteps(bake);
                this.updateGlobalTimerBanner();
                this.currentScreen = 'timelineView';
            },

            showRecipeDetail(recipeKey) {
                this.hideAllScreens();
                const recipes = this.getRecipes();
                const recipe = recipes[recipeKey];
                const el = document.getElementById('recipeDetailView');
                el.classList.remove('hidden');
                el.classList.add('screen-enter');
                document.getElementById('recipeDetailName').textContent = recipe.name;

                // Ingredients card
                let html = `<div class="recipe-detail-card"><h3>Ingredients</h3>`;
                recipe.ingredients.forEach(ing => {
                    html += `<div class="ingredient-item"><label>${ing}</label></div>`;
                });
                if (recipe.note) html += `<div class="note">${recipe.note}</div>`;
                html += `</div>`;

                // Steps card â€” show ALL steps including branch steps with section labels
                html += `<div class="recipe-detail-card"><h3>Steps</h3>`;
                const branchLabels = {
                    'today': 'ðŸ”¥ Bake Day',
                    'cold': 'â„ï¸ Cold Proof Option',
                    'refrigerate': 'â„ï¸ Refrigerate Option',
                    'freeze': 'ðŸ§Š Freeze Option'
                };
                let lastBranch = null;
                recipe.steps.forEach((step, i) => {
                    // Insert branch section label when switching branches
                    if (step.branch && step.branch !== lastBranch) {
                        html += `<div class="recipe-detail-branch-label">${branchLabels[step.branch] || step.branch}</div>`;
                    }
                    if (!step.branch && lastBranch) {
                        lastBranch = null; // reset
                    }
                    if (step.branch) lastBranch = step.branch;

                    // Duration string
                    let dur = '';
                    if (step.expandable && step.options) {
                        dur = step.options.map(o => `${o.sets} sets Ã— ${step.foldInterval} min`).join(' / ');
                    } else if (step.duration && typeof step.duration === 'object') {
                        dur = `${step.duration.min}â€“${step.duration.max} ${step.duration.unit}`;
                    } else if (step.duration > 0) {
                        dur = `${step.duration} ${step.unit}`;
                    } else if (step.options) {
                        dur = step.options.map(o => o.name).join(' / ');
                    }

                    html += `<div class="recipe-detail-step"><h4>${step.name}</h4>`;
                    if (dur) html += `<div class="step-meta">${dur}</div>`;
                    if (step.guidance) {
                        if (step.guidance.visual) {
                            html += `<div class="step-visual"><ul>${step.guidance.visual.map(v => `<li>${v}</li>`).join('')}</ul></div>`;
                        }
                        if (step.guidance.tips) {
                            html += `<div class="step-tips">${step.guidance.tips.join(' â€¢ ')}</div>`;
                        }
                    }
                    if (step.postProofChoice) {
                        html += `<div class="step-meta" style="margin-top:6px;color:#0A84FF;">â†“ Choose next path when baking</div>`;
                    }
                    html += `</div>`;
                });
                html += `</div>`;
                html += `<button class="btn btn-success mt-20" style="width:100%" onclick="app.showTimelineSetup('${recipeKey}')">Start This Recipe</button>`;
                document.getElementById('recipeDetailContent').innerHTML = html;
                this.currentScreen = 'recipeDetail';
            },

            showAddRecipe() {
                this.hideAllScreens();
                const el = document.getElementById('addRecipeScreen');
                el.classList.remove('hidden');
                el.classList.add('screen-enter');
                document.getElementById('newRecipeName').value = '';
                document.getElementById('newRecipeDesc').value = '';
                document.getElementById('newRecipeIngredients').value = '';
                document.getElementById('newRecipeSteps').innerHTML = '';
                this.newStepCount = 0;
                this.addNewStepField();
                this.currentScreen = 'addRecipe';
            },

            addNewStepField() {
                const container = document.getElementById('newRecipeSteps');
                const idx = this.newStepCount++;
                const card = document.createElement('div');
                card.className = 'add-step-card';
                card.id = `newStep_${idx}`;
                card.innerHTML = `
                    <div class="form-group"><label>Step ${idx + 1} Name</label><input type="text" id="stepName_${idx}" placeholder="e.g. Mix dough"></div>
                    <div class="add-step-row">
                        <div class="form-group"><label>Duration</label><input type="number" id="stepDur_${idx}" placeholder="0" min="0"></div>
                        <div class="form-group"><label>Unit</label><select id="stepUnit_${idx}"><option value="minutes">Minutes</option><option value="hours">Hours</option></select></div>
                    </div>
                    <div class="form-group"><label>Tips (one per line)</label><textarea id="stepTips_${idx}" placeholder="Helpful tips..." style="min-height:60px"></textarea></div>
                    <button class="remove-step-btn" onclick="document.getElementById('newStep_${idx}').remove()">Remove step</button>
                `;
                container.appendChild(card);
            },

            saveCustomRecipe() {
                const name = document.getElementById('newRecipeName').value.trim();
                const desc = document.getElementById('newRecipeDesc').value.trim();
                const ingText = document.getElementById('newRecipeIngredients').value.trim();
                if (!name) { alert('Please enter a recipe name.'); return; }
                if (!ingText) { alert('Please enter at least one ingredient.'); return; }

                const ingredients = ingText.split('\n').map(l => l.trim()).filter(l => l);
                const stepCards = document.querySelectorAll('[id^="newStep_"]');
                const steps = [];
                stepCards.forEach(card => {
                    const id = card.id.replace('newStep_', '');
                    const sName = document.getElementById(`stepName_${id}`).value.trim();
                    const sDur = parseInt(document.getElementById(`stepDur_${id}`).value) || 0;
                    const sUnit = document.getElementById(`stepUnit_${id}`).value;
                    const sTips = document.getElementById(`stepTips_${id}`).value.trim().split('\n').map(l => l.trim()).filter(l => l);
                    if (sName) {
                        const step = { name: sName, duration: sDur, unit: sUnit };
                        if (sTips.length) step.guidance = { tips: sTips };
                        steps.push(step);
                    }
                });
                if (steps.length === 0) { alert('Please add at least one step.'); return; }

                const key = name.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_|_$/g, '');
                this.customRecipes[key] = { name, description: desc, ingredients, steps };
                this.saveCustomRecipes();
                this.showMainScreen();
            },

            // â”€â”€â”€ Rendering â”€â”€â”€
            renderRecipeBook() {
                const container = document.getElementById('recipeBookCard');
                const recipes = this.getRecipes();
                const keys = Object.keys(recipes);

                let html = `<h2>Recipes</h2>`;
                keys.forEach(key => {
                    const r = recipes[key];
                    html += `<div class="recipe-book-item" onclick="app.showRecipeDetail('${key}')">
                        <div class="recipe-book-item-info"><h4>${r.name}</h4><p>${r.description || ''}</p></div>
                        <span class="chevron">â€º</span>
                    </div>`;
                });
                html += `<button class="btn btn-secondary mt-20" style="width:100%" onclick="app.showAddRecipe()">+ Add Recipe</button>`;
                container.innerHTML = html;
            },

            fmtDT(date) {
                const day = date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
                const time = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
                return `${day} ${time}`;
            },

            fmtT(date) {
                return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
            },

            renderActiveBakes() {
                const container = document.getElementById('activeBakesList');
                if (this.activeBakes.length === 0) {
                    container.innerHTML = '<div class="empty-state">No active bakes. Start a new one!</div>';
                    return;
                }
                container.innerHTML = this.activeBakes.map(bake => {
                    const cs = this.getCurrentStep(bake);
                    return `<div class="bake-card">
                        <div class="bake-card-info"><h3>${bake.recipeName}</h3><p>Current: ${cs.name} â€¢ Started: ${this.fmtDT(new Date(bake.steps[0].time))}</p></div>
                        <div class="bake-card-actions">
                            <button class="btn" onclick="app.showTimelineView('${bake.id}')">Continue</button>
                            <button class="btn btn-danger" onclick="app.finishBake('${bake.id}')">Finish</button>
                        </div>
                    </div>`;
                }).join('');
                this.updateGlobalTimerBanner();
            },

            renderRecipeGrid() {
                const container = document.getElementById('recipeGrid');
                const recipes = this.getRecipes();
                container.innerHTML = Object.keys(recipes).map(key => {
                    const r = recipes[key];
                    return `<div class="recipe-card" onclick="app.showTimelineSetup('${key}')"><h3>${r.name}</h3><p>${r.description || ''}</p></div>`;
                }).join('');
            },

            selectMode(mode) {
                this.mode = mode;
                document.querySelectorAll('.segmented-btn').forEach(b => b.classList.remove('active'));
                document.querySelector(`.segmented-btn[data-mode="${mode}"]`).classList.add('active');
                document.getElementById('startTimeGroup').classList.toggle('hidden', mode !== 'forward');
                document.getElementById('endTimeGroup').classList.toggle('hidden', mode !== 'backward');
            },

            setDefaultStartTime() {
                const now = new Date();
                now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
                const v = now.toISOString().slice(0, 16);
                document.getElementById('startTime').value = v;
                document.getElementById('endTime').value = v;
            },

            renderRecipeOptions() {
                const recipes = this.getRecipes();
                const recipe = recipes[this.selectedRecipe];
                const container = document.getElementById('recipeOptions');
                const optionSteps = recipe.steps.filter(step => step.options && !step.branch);
                if (optionSteps.length === 0) { container.innerHTML = ''; return; }

                container.innerHTML = '<h3>Options</h3>' + optionSteps.map(step => {
                    const ai = recipe.steps.indexOf(step);
                    return `<div class="option-group"><h4>${step.name}</h4><div class="pill-group">
                        ${step.options.map((opt, oi) => `<input type="radio" class="pill-chip" name="option_${ai}" id="option_${ai}_${oi}" value="${oi}" ${oi === 0 ? 'checked' : ''}><label for="option_${ai}_${oi}">${opt.name}</label>`).join('')}
                    </div></div>`;
                }).join('');
            },

            calculateTimeline() {
                const recipes = this.getRecipes();
                const recipe = recipes[this.selectedRecipe];
                const startingStepIndex = parseInt(document.getElementById('startingStep').value);
                let startTime;

                if (this.mode === 'forward') {
                    startTime = new Date(document.getElementById('startTime').value);
                } else {
                    const endTime = new Date(document.getElementById('endTime').value);
                    const totalDuration = this.calcTotalDur(recipe, startingStepIndex);
                    startTime = new Date(endTime - totalDuration);
                }

                const selectedOptions = {};
                recipe.steps.forEach((step, index) => {
                    if (step.options) {
                        const sel = document.querySelector(`input[name="option_${index}"]:checked`);
                        if (sel) selectedOptions[index] = parseInt(sel.value);
                    }
                });

                const bake = {
                    id: Date.now().toString(),
                    recipeKey: this.selectedRecipe,
                    recipeName: recipe.name,
                    mode: this.mode,
                    selectedOptions,
                    ingredientsChecked: {},
                    steps: [],
                    currentStepIndex: 0,
                    startingStepIndex
                };

                let currentTime = new Date(startTime);
                const startingFromBranch = recipe.steps[startingStepIndex] && recipe.steps[startingStepIndex].branch;
                const startBranch = startingFromBranch ? recipe.steps[startingStepIndex].branch : null;

                recipe.steps.forEach((step, index) => {
                    // When starting from a branch step, only include steps in that branch
                    // from the starting index onward
                    if (startingFromBranch) {
                        if (index < startingStepIndex) return;
                        if (step.branch && step.branch !== startBranch && step.branch !== 'today') return;
                        if (!step.branch) return; // skip non-branch steps when starting from a branch
                    } else {
                        if (step.branch) return; // skip branch steps during initial timeline
                    }
                    const isCompleted = index < startingStepIndex;
                    let duration;

                    if (step.expandable && step.options) {
                        const soi = selectedOptions[index] || 0;
                        const opt = step.options[soi];
                        for (let s = 1; s <= opt.sets; s++) {
                            bake.steps.push({
                                name: `${step.name} (${s}/${opt.sets})`,
                                time: new Date(currentTime), duration: step.foldInterval, unit: 'minutes',
                                guidance: step.guidance, completed: isCompleted,
                                selectedOption: opt.name, stepIndex: index
                            });
                            currentTime = new Date(currentTime.getTime() + step.foldInterval * 60000);
                        }
                    } else if (step.options) {
                        const soi = selectedOptions[index] || 0;
                        const opt = step.options[soi];
                        duration = opt.duration || step.duration || 0;
                        const unit = opt.unit || step.unit;
                        bake.steps.push({
                            name: step.name, time: new Date(currentTime), duration, unit,
                            guidance: step.guidance, completed: isCompleted,
                            selectedOption: opt.name, stepIndex: index,
                            postProofChoice: step.postProofChoice || false
                        });
                        currentTime = new Date(currentTime.getTime() + duration * (unit === 'hours' ? 3600000 : 60000));
                    } else {
                        if (typeof step.duration === 'object' && step.duration.min) {
                            duration = (step.duration.min + step.duration.max) / 2;
                        } else {
                            duration = step.duration || 0;
                        }
                        bake.steps.push({
                            name: step.name, time: new Date(currentTime), duration, unit: step.unit || 'minutes',
                            guidance: step.guidance, completed: isCompleted, stepIndex: index,
                            postProofChoice: step.postProofChoice || false
                        });
                        const u = step.unit || 'minutes';
                        currentTime = new Date(currentTime.getTime() + duration * (u === 'hours' ? 3600000 : 60000));
                    }
                });

                this.activeBakes.push(bake);
                this.saveActiveBakes();
                this.showTimelineView(bake.id);
            },

            calcTotalDur(recipe, startIdx = 0) {
                let total = 0;
                const startingFromBranch = recipe.steps[startIdx] && recipe.steps[startIdx].branch;
                const startBranch = startingFromBranch ? recipe.steps[startIdx].branch : null;
                recipe.steps.forEach((step, i) => {
                    if (i < startIdx) return;
                    if (startingFromBranch) {
                        if (!step.branch) return;
                        if (step.branch !== startBranch && step.branch !== 'today') return;
                    } else {
                        if (step.branch) return;
                    }
                    let d;
                    if (step.expandable && step.options) {
                        total += step.options[0].sets * step.foldInterval * 60000;
                    } else if (step.options) {
                        d = step.options[0].duration || step.duration || 0;
                        const u = step.options[0].unit || step.unit || 'minutes';
                        total += d * (u === 'hours' ? 3600000 : 60000);
                    } else {
                        if (typeof step.duration === 'object' && step.duration.min) d = (step.duration.min + step.duration.max) / 2;
                        else d = step.duration || 0;
                        const u = step.unit || 'minutes';
                        total += d * (u === 'hours' ? 3600000 : 60000);
                    }
                });
                return total;
            },

            renderIngredients(bake) {
                const recipes = this.getRecipes();
                const recipe = recipes[bake.recipeKey];
                if (!recipe) return;
                const container = document.getElementById('ingredientsSection');
                const mult = bake.ingredientMultiplier || 1;

                let noteHtml = '';
                if (recipe.note) noteHtml = `<div style="font-size:13px;color:#8E8E93;padding:8px 0;border-top:0.5px solid rgba(60,60,67,0.36);margin-top:4px;">${recipe.note}</div>`;

                container.innerHTML = `
                    <div class="ingredients-header"><h3>Ingredients</h3>
                        <div class="multiplier-control">
                            ${[1,2,3,4].map(m => `<button class="multiplier-btn ${mult===m?'active':''}" onclick="app.setMultiplier('${bake.id}',${m})">${m}x</button>`).join('')}
                        </div>
                    </div>
                    ${recipe.ingredients.map((ing, i) => {
                        const checked = bake.ingredientsChecked[i] || false;
                        const scaled = mult > 1 ? this.scaleIng(ing, mult) : ing;
                        return `<div class="ingredient-item ${checked?'checked':''}">
                            <input type="checkbox" id="ing_${i}" ${checked?'checked':''} onchange="app.toggleIng('${bake.id}',${i})">
                            <label for="ing_${i}">${scaled}</label>
                        </div>`;
                    }).join('')}
                    ${noteHtml}
                `;
            },

            setMultiplier(bakeId, m) {
                const bake = this.activeBakes.find(b => b.id === bakeId);
                if (!bake) return;
                bake.ingredientMultiplier = m;
                this.saveActiveBakes();
                this.renderIngredients(bake);
            },

            scaleIng(text, mult) {
                return text.replace(/(\([^)]*\))|(\d+\.?\d*)/g, (match, paren, num) => {
                    if (paren) return paren;
                    if (num) {
                        const s = parseFloat(num) * mult;
                        return s % 1 === 0 ? s.toString() : parseFloat(s.toFixed(2)).toString();
                    }
                    return match;
                });
            },

            toggleIng(bakeId, idx) {
                const bake = this.activeBakes.find(b => b.id === bakeId);
                if (!bake) return;
                bake.ingredientsChecked[idx] = !bake.ingredientsChecked[idx];
                this.saveActiveBakes();
                this.renderIngredients(bake);
            },

            renderTimelineSteps(bake) {
                const container = document.getElementById('timelineSteps');
                const csi = this.getCurrentStepIndex(bake);
                const recipes = this.getRecipes();
                const recipe = recipes[bake.recipeKey];

                container.innerHTML = '<h3>Timeline</h3>' + bake.steps.map((step, index) => {
                    const recipeStep = recipe ? recipe.steps[step.stepIndex] : null;
                    const isCompleted = step.completed;
                    const isActive = index === csi && !step.completed;
                    const timeStr = this.fmtDT(step.time);
                    const durStr = step.duration > 0 ? `${step.duration} ${step.unit}` : 'Ready';
                    const needsChoice = step.postProofChoice && isActive && !step.postProofDecision;
                    const needsFrozen = step.waitingForFrozenInput && isActive;

                    // Determine choice card content based on recipe
                    let choiceHtml = '';
                    if (needsChoice) {
                        if (bake.recipeKey === 'pizza') {
                            choiceHtml = `<div class="choice-cards">
                                <div class="choice-card" onclick="app.handlePostProofChoice('${bake.id}',${index},'today')"><div class="choice-card-icon">ðŸ”¥</div><div class="choice-card-text"><h4>Continue baking</h4><p>Preheat oven and bake today</p></div></div>
                                <div class="choice-card" onclick="app.handlePostProofChoice('${bake.id}',${index},'refrigerate')"><div class="choice-card-icon">â„ï¸</div><div class="choice-card-text"><h4>Refrigerate</h4><p>Store 24-48 hours for more flavor</p></div></div>
                                <div class="choice-card" onclick="app.handlePostProofChoice('${bake.id}',${index},'freeze')"><div class="choice-card-icon">ðŸ§Š</div><div class="choice-card-text"><h4>Freeze</h4><p>Save for up to 2 months</p></div></div>
                            </div>`;
                        } else if (bake.recipeKey === 'sourdough') {
                            choiceHtml = `<div class="choice-cards">
                                <div class="choice-card" onclick="app.handlePostProofChoice('${bake.id}',${index},'today')"><div class="choice-card-icon">ðŸ”¥</div><div class="choice-card-text"><h4>Room temp proof</h4><p>1-2.5 hours, proof until poke test passes</p></div></div>
                                <div class="choice-card" onclick="app.handlePostProofChoice('${bake.id}',${index},'cold')"><div class="choice-card-icon">â„ï¸</div><div class="choice-card-text"><h4>Cold proof</h4><p>8-16 hours in fridge, better flavor + easier scoring</p></div></div>
                            </div>`;
                        }
                    }

                    return `<div class="step-card ${isCompleted?'completed':''} ${isActive?'active':''}" id="step_${index}">
                        <div class="step-header">
                            <div style="flex:1">
                                <div class="step-title">${step.name}</div>
                                ${step.selectedOption ? `<div style="color:#8E8E93;font-size:13px">${step.selectedOption}</div>` : ''}
                            </div>
                            <div style="display:flex;align-items:center;gap:8px">
                                ${step.guidance ? `<button class="info-btn" onclick="app.toggleGuidance(${index})" id="infobtn_${index}">i</button>` : ''}
                                <div class="step-time">${timeStr}</div>
                            </div>
                        </div>
                        <div class="step-duration">${durStr}</div>
                        ${step.guidance ? `<div class="step-guidance"><div class="guidance-content hidden" id="guidance_${index}">
                            ${step.guidance.visual ? `<strong>Visual cues:</strong><ul>${step.guidance.visual.map(c=>`<li>${c}</li>`).join('')}</ul>` : ''}
                            ${step.guidance.tips ? `<strong>Tips:</strong><ul>${step.guidance.tips.map(t=>`<li>${t}</li>`).join('')}</ul>` : ''}
                        </div></div>` : ''}
                        ${choiceHtml}
                        ${needsFrozen ? `<div class="frozen-input-section">
                            <label>When did you pull the dough out of the freezer?</label>
                            <input type="datetime-local" id="frozenPullTime_${index}">
                            <button class="btn btn-success" onclick="app.setFrozenPullTime('${bake.id}',${index})">Set Time & Continue</button>
                        </div>` : ''}
                        ${isActive && !isCompleted && !needsChoice && !needsFrozen ? `
                            <div class="step-toggle-row">
                                <span class="step-toggle-label">Mark complete</span>
                                <label class="ios-toggle"><input type="checkbox" onchange="app.completeStep('${bake.id}',${index})"><span class="slider"></span></label>
                            </div>
                            ${recipeStep && recipeStep.options && !recipeStep.expandable ? `<div class="step-actions"><button class="btn btn-secondary" onclick="app.adjustStepOptions('${bake.id}',${index})">Adjust Options</button></div>` : ''}
                        ` : ''}
                    </div>`;
                }).join('');
            },

            toggleGuidance(i) {
                const c = document.getElementById(`guidance_${i}`);
                const b = document.getElementById(`infobtn_${i}`);
                c.classList.toggle('hidden');
                b.classList.toggle('active');
            },

            handlePostProofChoice(bakeId, stepIndex, choice) {
                const bake = this.activeBakes.find(b => b.id === bakeId);
                if (!bake) return;
                const recipes = this.getRecipes();
                const recipe = recipes[bake.recipeKey];

                bake.steps[stepIndex].postProofDecision = choice;
                bake.steps = bake.steps.slice(0, stepIndex + 1);
                const now = new Date();

                if (bake.recipeKey === 'sourdough') {
                    let currentTime = new Date(now);
                    if (choice === 'cold') {
                        // Add cold proof step
                        const coldStep = recipe.steps.find(s => s.branch === 'cold');
                        bake.steps.push({
                            name: coldStep.name, time: new Date(currentTime),
                            duration: coldStep.duration, unit: coldStep.unit,
                            guidance: coldStep.guidance, completed: false,
                            branch: 'cold', stepIndex: recipe.steps.indexOf(coldStep)
                        });
                        currentTime = new Date(currentTime.getTime() + coldStep.duration * 60000);
                    }
                    // Add baking steps
                    recipe.steps.filter(s => s.branch === 'today').forEach(step => {
                        const d = typeof step.duration === 'object' ? (step.duration.min + step.duration.max) / 2 : (step.duration || 0);
                        const u = (typeof step.duration === 'object' ? step.duration.unit : step.unit) || 'minutes';
                        bake.steps.push({
                            name: step.name, time: new Date(currentTime),
                            duration: d, unit: u, guidance: step.guidance,
                            completed: false, branch: 'today',
                            stepIndex: recipe.steps.indexOf(step)
                        });
                        currentTime = new Date(currentTime.getTime() + d * (u === 'hours' ? 3600000 : 60000));
                    });
                } else if (bake.recipeKey === 'pizza') {
                    let currentTime = new Date(now);
                    if (choice === 'today') {
                        recipe.steps.filter(s => s.branch === 'today').forEach(step => {
                            const d = step.duration || 0;
                            bake.steps.push({ name: step.name, time: new Date(currentTime), duration: d, unit: step.unit, guidance: step.guidance, completed: false, branch: 'today', stepIndex: recipe.steps.indexOf(step) });
                            currentTime = new Date(currentTime.getTime() + d * (step.unit === 'hours' ? 3600000 : 60000));
                        });
                    } else if (choice === 'refrigerate') {
                        const fs = recipe.steps.find(s => s.branch === 'refrigerate');
                        bake.steps.push({ name: fs.name, time: new Date(currentTime), duration: fs.duration, unit: fs.unit, guidance: fs.guidance, completed: false, branch: 'refrigerate', stepIndex: recipe.steps.indexOf(fs) });
                        currentTime = new Date(currentTime.getTime() + fs.duration * 60000);
                        recipe.steps.filter(s => s.branch === 'today').forEach(step => {
                            const d = step.duration || 0;
                            bake.steps.push({ name: step.name, time: new Date(currentTime), duration: d, unit: step.unit, guidance: step.guidance, completed: false, branch: 'today', stepIndex: recipe.steps.indexOf(step) });
                            currentTime = new Date(currentTime.getTime() + d * (step.unit === 'hours' ? 3600000 : 60000));
                        });
                    } else if (choice === 'freeze') {
                        const fz = recipe.steps.find(s => s.branch === 'freeze');
                        bake.steps.push({ name: fz.name, time: new Date(now), duration: 0, unit: fz.unit, guidance: fz.guidance, completed: false, branch: 'freeze', stepIndex: recipe.steps.indexOf(fz) });
                        bake.steps.push({
                            name: "Thaw & proof", time: new Date(now), duration: 180, unit: 'minutes',
                            guidance: { visual: ["Thaw in fridge 12-24 hours", "Then proof at room temp 1-3 hours until puffy"], tips: ["Dough should be relaxed and stretchy before shaping"] },
                            completed: false, branch: 'freeze', stepIndex: recipe.steps.indexOf(fz), waitingForFrozenInput: true
                        });
                        let ct = new Date(now.getTime() + 180 * 60000);
                        recipe.steps.filter(s => s.branch === 'today').forEach(step => {
                            const d = step.duration || 0;
                            bake.steps.push({ name: step.name, time: new Date(ct), duration: d, unit: step.unit, guidance: step.guidance, completed: false, branch: 'today', stepIndex: recipe.steps.indexOf(step) });
                            ct = new Date(ct.getTime() + d * (step.unit === 'hours' ? 3600000 : 60000));
                        });
                    }
                }

                this.saveActiveBakes();
                this.renderTimelineSteps(bake);
                this.updateGlobalTimerBanner();
            },

            setFrozenPullTime(bakeId, stepIndex) {
                const bake = this.activeBakes.find(b => b.id === bakeId);
                if (!bake) return;
                const input = document.getElementById(`frozenPullTime_${stepIndex}`);
                if (!input || !input.value) { alert('Please select a time.'); return; }
                const pullTime = new Date(input.value);
                bake.steps[stepIndex].time = new Date(pullTime);
                bake.steps[stepIndex].waitingForFrozenInput = false;
                let ct = new Date(pullTime.getTime() + 180 * 60000);
                for (let i = stepIndex + 1; i < bake.steps.length; i++) {
                    bake.steps[i].time = new Date(ct);
                    bake.steps[i].notified = false;
                    const d = bake.steps[i].duration || 0;
                    ct = new Date(ct.getTime() + d * (bake.steps[i].unit === 'hours' ? 3600000 : 60000));
                }
                this.saveActiveBakes();
                this.renderTimelineSteps(bake);
                this.updateGlobalTimerBanner();
            },

            completeStep(bakeId, stepIndex) {
                const bake = this.activeBakes.find(b => b.id === bakeId);
                if (!bake) return;
                const now = new Date();
                bake.steps[stepIndex].completed = true;
                bake.steps[stepIndex].completedAt = now;
                bake.currentStepIndex = stepIndex + 1;
                let ct = new Date(now);
                for (let i = stepIndex + 1; i < bake.steps.length; i++) {
                    bake.steps[i].time = new Date(ct);
                    bake.steps[i].notified = false;
                    const d = bake.steps[i].duration || 0;
                    ct = new Date(ct.getTime() + d * (bake.steps[i].unit === 'hours' ? 3600000 : 60000));
                }
                this.saveActiveBakes();
                this.renderTimelineSteps(bake);
                this.updateGlobalTimerBanner();
            },

            getCurrentStep(bake) {
                for (let i = 0; i < bake.steps.length; i++) { if (!bake.steps[i].completed) return bake.steps[i]; }
                return bake.steps[bake.steps.length - 1];
            },

            getCurrentStepIndex(bake) {
                for (let i = 0; i < bake.steps.length; i++) { if (!bake.steps[i].completed) return i; }
                return bake.steps.length - 1;
            },

            updateGlobalTimerBanner() {
                if (this.currentScreen === 'timelineView' && this.currentBakeId) {
                    const bake = this.activeBakes.find(b => b.id === this.currentBakeId);
                    if (bake) { this.updatePerBakeTimerBanner(bake); return; }
                }
                document.getElementById('timerBanner').classList.remove('per-bake');
                if (this.activeBakes.length === 0) { document.getElementById('timerBanner').classList.add('hidden'); return; }

                let urgent = null, shortest = Infinity;
                const now = new Date();
                this.activeBakes.forEach(bake => {
                    const cs = bake.steps[this.getCurrentStepIndex(bake)];
                    if (!cs.completed) {
                        const tr = cs.time - now;
                        if (tr < shortest) { shortest = tr; urgent = bake; }
                    }
                });
                if (!urgent) { document.getElementById('timerBanner').classList.add('hidden'); return; }

                document.getElementById('timerBanner').classList.remove('hidden');
                const pf = document.getElementById('bannerProgressFill');
                const csi = this.getCurrentStepIndex(urgent);
                const cs = urgent.steps[csi];

                document.getElementById('bannerRecipeName').textContent = urgent.recipeName;
                document.getElementById('bannerCurrentStep').textContent = `${urgent.recipeName} â€” ${cs.name}`;

                const nsi = csi + 1;
                let tr, tsd;
                if (nsi < urgent.steps.length) {
                    const se = urgent.steps[nsi].time.getTime(), ss = cs.time.getTime();
                    tr = se - now.getTime(); tsd = se - ss;
                } else {
                    tsd = cs.duration * (cs.unit === 'hours' ? 3600000 : 60000);
                    tr = (cs.time.getTime() + tsd) - now.getTime();
                }

                if (tr > 0 && tsd > 0) {
                    pf.classList.remove('done'); pf.style.width = `${Math.max(0,Math.min(100,(tr/tsd)*100))}%`;
                    document.getElementById('bannerTimeRemaining').textContent = this.fmtTR(tr);
                    document.getElementById('bannerTimeRemaining').style.color = '#8E8E93';
                } else if (!cs.completed) {
                    pf.classList.add('done'); pf.style.width = '0%';
                    document.getElementById('bannerTimeRemaining').textContent = 'Ready!';
                    document.getElementById('bannerTimeRemaining').style.color = '#FFD60A';
                } else {
                    pf.classList.add('done'); pf.style.width = '0%';
                    document.getElementById('bannerTimeRemaining').textContent = 'Done';
                    document.getElementById('bannerTimeRemaining').style.color = '#30D158';
                }

                if (csi < urgent.steps.length - 1) {
                    document.getElementById('bannerNextStep').textContent = `Next: ${urgent.steps[csi+1].name} at ${this.fmtT(urgent.steps[csi+1].time)}`;
                } else {
                    document.getElementById('bannerNextStep').textContent = 'Final step!';
                }
            },

            updatePerBakeTimerBanner(bake) {
                const banner = document.getElementById('timerBanner');
                const pf = document.getElementById('bannerProgressFill');
                const csi = this.getCurrentStepIndex(bake);
                const cs = bake.steps[csi];
                const now = new Date();

                banner.classList.remove('hidden');
                banner.classList.add('per-bake');
                document.getElementById('bannerRecipeName').textContent = bake.recipeName;
                document.getElementById('bannerCurrentStep').textContent = cs.name;

                if (cs.completed) {
                    document.getElementById('bannerTimeRemaining').textContent = 'All done!';
                    document.getElementById('bannerTimeRemaining').style.color = '#30D158';
                    pf.classList.add('done'); pf.style.width = '0%';
                } else {
                    pf.classList.remove('done');
                    const nsi = csi + 1;
                    let ct, tsd;
                    if (nsi < bake.steps.length) {
                        const se = bake.steps[nsi].time.getTime(), ss = cs.time.getTime();
                        ct = se - now.getTime(); tsd = se - ss;
                    } else {
                        tsd = cs.duration * (cs.unit === 'hours' ? 3600000 : 60000);
                        ct = (cs.time.getTime() + tsd) - now.getTime();
                    }
                    if (ct > 0 && tsd > 0) {
                        pf.style.width = `${Math.max(0,Math.min(100,(ct/tsd)*100))}%`;
                        document.getElementById('bannerTimeRemaining').textContent = this.fmtTR(ct);
                        document.getElementById('bannerTimeRemaining').style.color = '#8E8E93';
                    } else {
                        pf.classList.add('done'); pf.style.width = '0%';
                        document.getElementById('bannerTimeRemaining').textContent = 'Ready!';
                        document.getElementById('bannerTimeRemaining').style.color = '#FFD60A';
                    }
                }
                if (csi < bake.steps.length - 1) {
                    document.getElementById('bannerNextStep').textContent = `Next: ${bake.steps[csi+1].name} at ${this.fmtT(bake.steps[csi+1].time)}`;
                } else {
                    document.getElementById('bannerNextStep').textContent = 'Final step!';
                }
            },

            handleBannerClick() {
                if (this.currentScreen === 'timelineView' && this.currentBakeId) {
                    const bake = this.activeBakes.find(b => b.id === this.currentBakeId);
                    if (bake) {
                        const el = document.getElementById(`step_${this.getCurrentStepIndex(bake)}`);
                        if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                } else {
                    const id = this.getNextActiveBakeId();
                    if (id) this.showTimelineView(id);
                }
            },

            getNextActiveBakeId() {
                if (this.activeBakes.length === 0) return null;
                let urgent = this.activeBakes[0], shortest = Infinity;
                const now = new Date();
                this.activeBakes.forEach(bake => {
                    const cs = bake.steps[this.getCurrentStepIndex(bake)];
                    if (!cs.completed) {
                        const tr = cs.time - now;
                        if (tr < shortest) { shortest = tr; urgent = bake; }
                    }
                });
                return urgent.id;
            },

            fmtTR(ms) {
                const ts = Math.floor(ms / 1000);
                const h = Math.floor(ts / 3600), m = Math.floor((ts % 3600) / 60), s = ts % 60;
                return h > 0 ? `${h}h ${m}m` : `${m}m ${s.toString().padStart(2,'0')}s`;
            },

            startTimerUpdates() {
                if ('Notification' in window && Notification.permission === 'default') Notification.requestPermission();
                this.timerInterval = setInterval(() => {
                    this.updateGlobalTimerBanner();
                    this.checkForNotifications();
                }, 1000);
            },

            checkForNotifications() {
                const now = new Date();
                this.activeBakes.forEach(bake => {
                    bake.steps.forEach((step, i) => {
                        if (step.completed || step.notified) return;
                        if (step.time - now <= 0) {
                            step.notified = true;
                            this.sendNotification(bake, step, i);
                            this.saveActiveBakes();
                        }
                    });
                });
            },

            sendNotification(bake, step, si) {
                if ('Notification' in window && Notification.permission === 'granted') {
                    const ns = bake.steps[si + 1];
                    const body = ns ? `Time for: ${step.name}\nNext: ${ns.name}` : `Time for: ${step.name}\nFinal step!`;
                    const n = new Notification(`${bake.recipeName}`, { body, tag: `rs-${bake.id}-${si}`, requireInteraction: true, vibrate: [200, 100, 200] });
                    n.onclick = () => { window.focus(); this.showTimelineView(bake.id); n.close(); };
                }
                this.showToast(bake.recipeName, step.name);
                this.playAlert();
            },

            showToast(title, stepName) {
                const ex = document.querySelector('.notification-toast');
                if (ex) ex.remove();
                const t = document.createElement('div');
                t.className = 'notification-toast';
                t.innerHTML = `<div class="notification-toast-title">${title}</div><div class="notification-toast-body">Time for: ${stepName}</div>`;
                document.body.appendChild(t);
                setTimeout(() => { t.style.animation = 'slideDown 0.3s reverse forwards'; setTimeout(() => t.remove(), 300); }, 5000);
                t.onclick = () => t.remove();
            },

            playAlert() {
                try {
                    const ac = new (window.AudioContext || window.webkitAudioContext)();
                    const o = ac.createOscillator(), g = ac.createGain();
                    o.connect(g); g.connect(ac.destination);
                    o.frequency.value = 800; o.type = 'sine';
                    g.gain.setValueAtTime(0.3, ac.currentTime);
                    g.gain.exponentialRampToValueAtTime(0.01, ac.currentTime + 0.5);
                    o.start(ac.currentTime); o.stop(ac.currentTime + 0.5);
                } catch (e) {}
            },

            adjustStepOptions(bakeId, bsi) {
                const bake = this.activeBakes.find(b => b.id === bakeId);
                if (!bake) return;
                const recipes = this.getRecipes();
                const recipe = recipes[bake.recipeKey];
                const rsi = bake.steps[bsi].stepIndex;
                const step = recipe.steps[rsi];
                if (!step || !step.options) return;

                const co = bake.selectedOptions[rsi] || 0;
                const oh = step.options.map((o, i) => `<option value="${i}" ${i===co?'selected':''}>${o.name}</option>`).join('');
                const modal = document.createElement('div');
                modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:1000;padding:20px;backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px)';
                modal.innerHTML = `<div style="background:#1C1C1E;padding:24px;border-radius:16px;max-width:400px;width:100%">
                    <h3 style="color:#fff;margin-bottom:16px;font-size:17px;font-weight:700">Adjust ${step.name}</h3>
                    <select id="optionSelect" style="width:100%;padding:14px;background:#2C2C2E;border:none;border-radius:12px;color:#FFF;font-size:17px;margin-bottom:16px">${oh}</select>
                    <div style="display:flex;gap:10px">
                        <button onclick="app.applyOptionChange('${bakeId}',${bsi})" style="flex:1;background:#0A84FF;color:white;border:none;padding:14px;border-radius:12px;cursor:pointer;font-size:17px;font-weight:600">Apply</button>
                        <button onclick="app.closeModal()" style="flex:1;background:#2C2C2E;color:white;border:none;padding:14px;border-radius:12px;cursor:pointer;font-size:17px;font-weight:600">Cancel</button>
                    </div></div>`;
                document.body.appendChild(modal);
                this.currentModal = modal;
            },

            applyOptionChange(bakeId, bsi) {
                const bake = this.activeBakes.find(b => b.id === bakeId);
                if (!bake) return;
                const noi = parseInt(document.getElementById('optionSelect').value);
                const recipes = this.getRecipes();
                const recipe = recipes[bake.recipeKey];
                const rsi = bake.steps[bsi].stepIndex;
                const rs = recipe.steps[rsi];
                const no = rs.options[noi];

                bake.selectedOptions[rsi] = noi;
                bake.steps[bsi].duration = no.duration;
                bake.steps[bsi].unit = no.unit || rs.unit;
                bake.steps[bsi].selectedOption = no.name;

                let ct = new Date(bake.steps[bsi].time);
                for (let i = bsi; i < bake.steps.length; i++) {
                    bake.steps[i].time = new Date(ct);
                    bake.steps[i].notified = false;
                    const d = bake.steps[i].duration || 0;
                    ct = new Date(ct.getTime() + d * (bake.steps[i].unit === 'hours' ? 3600000 : 60000));
                }
                this.saveActiveBakes();
                this.closeModal();
                this.showTimelineView(bakeId);
            },

            closeModal() {
                if (this.currentModal) { this.currentModal.remove(); this.currentModal = null; }
            },

            finishBake(bakeId) {
                const id = bakeId || this.currentBakeId;
                if (!id) return;
                if (confirm('Finish this bake? This cannot be undone.')) {
                    this.activeBakes = this.activeBakes.filter(b => b.id !== id);
                    this.saveActiveBakes();
                    this.showMainScreen();
                }
            }
        };

        document.addEventListener('DOMContentLoaded', () => app.init());
    </script>
</body>
</html>
